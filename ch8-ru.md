# Контейнер

## Могучий контейнер

<img src="images/jar.jpg" alt="http://blog.dwinegar.com/2011/06/another-jar.html" />

Мы видели как писать программы которые передают данные через ряд чистых функций, они декларативно описывают поведение. Но как насчёт управления потоком, обработки ошибок, асинхронности, состояния, и, в конце концов, побочных эффектов?! В этой главе, мы узнаем основу на которой построены все эти полезные абстракции.

Для начала мы создадим контейнер. Этот контейнер должен уметь содержать значения любых типов; контейнер, способный хранить только один тип, редко бывает полезен. Контейнер – это объект, но мы не будет добавлять ему никаких свойств или методов как в объектно-ориентированном подходе. Отнюдь, мы будем думать о нём как о сундуке с сокровищами - специальная коробка которая содержит наши ценные данные.

```js
class Container {
  constructor(x) {
    this.$value = x;
  }

  static of(x) {
    return new Container(x);
  }
}
```

Вот наш первый контейнер. Мы дали ему логичное название `Container`. `Container.of` – конструктор, который спасет нас от необходимости писать повсюду отвратительное ключевое слова `new`. Функция `of` не так проста как кажется, но пока что будем использовать её как способ положить что-либо в контейнер.

Давайте исследуем наш новый контейнер...

```js
Container.of(3);
// Container(3)

Container.of('hotdogs');
// Container("hotdogs")

Container.of(Container.of({ name: 'yoda' }));
// Container(Container({ name: 'yoda' }))
```

Если вы используете Node, то вы увидите `{$value: x}` несмотря на то, что на самом деле у нас `Container(x)`. Chrome будет выводить типы правильно, но это не принципиально, главное, что бы было понятно, что из себя представляет `Container`. В некоторых средах выполнения JS можно написать свой вариант функции `inspect`, но мы не будем такими дотошными. В этой книге, мы будем указывать вывод содержимого контейнера как если бы мы на самом деле переписали функцию `inspect`, поскольку это гораздо полезнее, чем `{$value: x}` как с педагогической, так и с эстетической точки зрения.

Давайте кое-что проясним перед тем как двигаться дальше:

* `Container` – это объект с одним свойством `$value`. Внутри контейнера будет храниться только одна вещь (хотя может и больше).

* `$value` не должно быть определённого типа, ведь в этом случае название «контейнер» не будет иметь смысла.

* После того как данные попали в контейнер, там они и остаются. Ничто не мешает их получить с помощью свойства `.$value`, но это нарушило бы саму идею создания контейнера.

Скоро станет понятно зачем мы всё это делаем, потерпите немного.

## Мой первый Функтор

Данные в контейнере, теперь нам нужен способ вызывать функции на них.

```js
// (a -> b) -> Container a -> Container b
Container.prototype.map = function (f) {
  return Container.of(f(this.$value));
};
```

Напоминает функцию `map` в массивах, только используется `Container a`, а не `[a]`. Но работает так же:

```js
Container.of(2).map(two => two + 2);
// Container(4)

Container.of('flamethrowers').map(s => s.toUpperCase());
// Container('FLAMETHROWERS')

Container.of('bombs').map(concat(' away')).map(prop('length'));
// Container(10)
```

Так как данные никогда не покидают контейнер, мы можем работать с ними как угодно, в том числе изменять их тип.

Минуточку, если продолжать вызывать `map` на результате вызова `map` это начнёт напоминать композицию! Что это ещё за математическая магия? Что ж, мы только что познакомились с функторами.

> Функтор – это тип, который реализует `map` и подчиняется некоторым законам.

Да, *функтор* это просто интерфейс с контрактом, можно назвать его *Mappable*, но это было бы слишком скучно. Функторы определяются в теории категорий, их строгое определение описано в конце главы. Сейчас предлагаю положиться на интуицию и посмотреть как мы можем использовать их на практике.

Зачем прятать значение в контейнер и применять функции через `map`? Возможно, стоит задать правильный вопрос: какие приемущества даёт нам вызов функций с использованием `map`? Дополнительный уровень абстракции при применении функции: её выполнение передаётся типу данных в контейнере – довольно мощная концепция.

## Maybe Шрёдингера

<img src="images/cat.png" alt="cool cat, need reference" />

Контейнер довольно скучный, обычно он называется `Identity` и ведёт себя как функция `id` (между ними есть математическая связь, её мы рассмотрим позже). Существуют и другие функторы, добавляющие полезное поведение во время вызова `map`.

> Полная реализация приведена в [Appendix B](./appendix_b.md#Maybe)

```js
class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  constructor(x) {
    this.$value = x;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  inspect() {
    return this.isNothing ? 'Nothing' : `Just(${inspect(this.$value)})`;
  }
}
```

`Maybe` похож на `Container`, с небольшой разницей: сначала он проверяет существуют ли данные и только потом применяет функцию – это помогает избегать раздражающих проблем с `null` и `undefined` (для учебных целей реализация упрощена).

```js
Maybe.of('Malkovich Malkovich').map(match(/a/ig));
// Just(['a', 'a'])

Maybe.of(null).map(match(/a/ig));
// Nothing

Maybe.of({ name: 'Boris' }).map(prop('age')).map(add(10));
// Nothing

Maybe.of({ name: 'Dinah', age: 14 }).map(prop('age')).map(add(10));
// Just(24)
```

Обратите внимание, программа не упала с ошибкой, когда мы вызываем `map` на нулевых значениях – `Maybe` каждый раз проверяет наличие данных и только потом вызывает функцию.

Вызов функций через `.` прекрасно работает, но по причинам упомянутым в первой части книги, мы бы хотели писать код в стиле отсутствия ссылок на данные. На самом деле, `map` полностью готов к тому, чтобы делегировать вызов функции любому функтору, который мы ему передадим:

```js
// map :: Functor f => (a -> b) -> f a -> f b
const map = curry((f, anyFunctor) => anyFunctor.map(f));
```

Отлично! Мы можем продолжать использовать композицию и `map` будет работать предсказуемо, `map` из библиотеки ramda работает также. Для наглядности мы иногда будем использовать вызов через точку, но для удобства будем пользоваться стилем с отсутствием ссылок на данные. Заметили? В примере выше я ввёл новую нотацию: `Functor f =>` значит, что `f` должна быть функтором, довольно очевидно, но мне показалось, что это стоит упомянуть.

## Примеры

In the wild, we'll typically see `Maybe` used in functions which might fail to return a result.

На практике, `Maybe` используется с функциями, которые могут завершиться с ошибкой.

```js
// safeHead :: [a] -> Maybe(a)
const safeHead = xs => Maybe.of(xs[0]);

// streetName :: Object -> Maybe String
const streetName = compose(map(prop('street')), safeHead, prop('addresses'));

streetName({ addresses: [] });
// Nothing

streetName({ addresses: [{ street: 'Shady Ln.', number: 4201 }] });
// Just('Shady Ln.')
```

`safeHead` похож на обычный `head`, но с добавлением безопасности типа. Когда `Maybe` появляется в коде происходит интересная вещь: мы вынуждены иметь дело с нулевыми значениями. Функция `safeHead` открыто заявляет, что может не вернуть значение и в этом нет ничего такого, поэтому она и возвращает `Maybe`, чтобы проинформировать нас об этом. Чтобы получить доступ к значению внутри `Maybe` придётся явно вызвать `map`. Всё это обеспечит нам здоровый сон, гарантируя, что `null` не выскочит из-за угла, словно чёрт из табакерки. Такой подход к коду как бы превращает наш код из глиняного дома в кирпичный, гарантируя более надёжную работу приложения.

Иногда функция может вернуть `Nothing` специально, чтобы сообщить об ошибке, например:

```js
// withdraw :: Number -> Account -> Maybe(Account)
const withdraw = curry((amount, { balance }) =>
  Maybe.of(balance >= amount ? { balance: balance - amount } : null));

// эта функция для примера, мы не добавляли её реализацию здесь.
// updateLedger :: Account -> Account
const updateLedger = account => account;

// remainingBalance :: Account -> String
const remainingBalance = ({ balance }) => `Your balance is $${balance}`;

// finishTransaction :: Account -> String
const finishTransaction = compose(remainingBalance, updateLedger);

// getTwenty :: Account -> Maybe(String)
const getTwenty = compose(map(finishTransaction), withdraw(20));

getTwenty({ balance: 200.00 });
// Just('Your balance is $180')

getTwenty({ balance: 10.00 });
// Nothing
```

`withdraw` начнёт крутить носом и вернет `Nothing`, если денег недостаточно, она также сообщает о том, что может вернуть `Nothing` и не оставляет нам выбора, кроме как `map`'ить всё, что она возвращает. Вместо `Just('..')`, мы получаем `Nothing`, как сигнал об ошибке и останавливаем последующие вызовы функций. Важно отметить: если `withdraw` не будет успешно выполнен, то `map` прервёт остальные вычисления (`finishTransaction`). Как раз то, что надо: мы не хотим обновлять баланс кошелька или лог транзакций, если не получилось успешно списать деньги.

## Высвобождение значения

Один момент часто упускается из виду – в конце-концов нам нужно будет произвести какой-либо побочный эффект: отправить JSON, вывести что-то на экран, записать файл на диск. Дзен буддист сказал бы: «Если у программы нет побочных эффектов, запущена ли она в принципе?». Программа отработала для своего собственного удовольствия? Может быть она просто зря потратила процессорное время и уснула?

Задача программы – получать, преобразовывать и хранить данные до тех пор, пока не настанет пора с ними попрощаться. В момент прощания мы как раз сможем получить данные с помощью `map`, поэтому, до этого времени им нет нужды покидать свой уютный контейнер. Зачастую можно обнаружить, что программист пытается достать данные из `Maybe` тем или иным способом, как будто как только он их получит произойдёт какая-то магия. Программист, помни: ты можешь находиться в ветке кода, которую данные не переживут. Код – он как кот Шрёдингера – находится сразу в нескольких состояниях и мы не должны открывать коробку до самого последнего момента. Такой подход позволяет коду быть линейным, несмотря на ветвление.

Тем не менее, есть одна лазейка: если всё же необходимо получить данные это можно сделать с помощью небольшой функции `maybe`.

```js
// maybe :: b -> (a -> b) -> Maybe a -> b
const maybe = curry((v, f, m) => {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

// getTwenty :: Account -> String
const getTwenty = compose(maybe('You\'re broke!', finishTransaction), withdraw(20));

getTwenty({ balance: 200.00 });
// 'Your balance is $180.00'

getTwenty({ balance: 10.00 });
// 'You\'re broke!'
```

С помощью `maybe` мы либо остановим выполнение и получим значение первого аргумента, либо продолжим без всяких `Maybe`. Функция `maybe` эквивалент оператора  `if/else`, её императивным аналогом было бы: `if (x !== null) { return f(x) }`.

По началу вам может быть не очень комфортно использовать `Maybe`. Пишущие на Swift и Scala поймут меня, так как `Maybe` является частью стандартной библиотеки этих язков под видом `Option(al)`. Большинству людей может показаться излишним всё время всё проверять на нулевые значение, даже тогда, когда они абсолютно уверены, что нулевого значения сейчас быть не может. Однако, это довольно быстро становится привычкой и, вероятно, вы начнёте ценить надёжность подобного подхода.

«Настоящая» реализация `Maybe` возвращает один из двух типов: «данные» или «нет данных», благодаря этому мы можем использовать `map` и на нулевых значениях тоже. Зачастую вы будете видеть типы `Some(x) / None` или `Just(x) / Nothing` вместо обычного `Maybe`.

## Чистая обработка ошибок

<img src="images/fists.jpg" alt="pick a hand... need a reference" />

Шок контент: конструкция `throw/catch` не является чистой. Когда выбрасывается исключение, вместо того чтобы вернуть значение мы бьём тревогу! Функция, извергая тысячи нулей и единиц, словно щиты и копья, ведёт освободительную войну против иноземного захватчика (входных данных). Благодаря новому другу `Either`, мы станем способны на большее, например – вернуть вежливое сообщение в ответ на ошибку, посмотрим:

> Полная реализация в [Appendix B](./appendix_b.md#Either)

```js
class Either {
  static of(x) {
    return new Right(x);
  }

  constructor(x) {
    this.$value = x;
  }
}

class Left extends Either {
  map(f) {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }
}

class Right extends Either {
  map(f) {
    return Either.of(f(this.$value));
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }
}

const left = x => new Left(x);
```

Классы `Left` и `Right` являются наследниками абстрактного класса `Either`, я нарочно пропустил реализацию класса `Either`, так как она нам не понадобится. Давайте же посмотрим на два новых класса в действии:

```js
Either.of('rain').map(str => `b${str}`); 
// Right('brain')

left('rain').map(str => `It's gonna ${str}, better bring your umbrella!`); 
// Left('rain')

Either.of({ host: 'localhost', port: 80 }).map(prop('host'));
// Right('localhost')

left('rolls eyes...').map(prop('host'));
// Left('rolls eyes...')
```

`Left` напоминает капризного ребёнка и попросту игнорирует все наши попытки вызвать `map`, тогда как `Right` работает в точности как `Container` (также известный как `Identity`). `Left` очень удобен для хранения сообщения об ошибке.

Допустим, что мы пишем функцию, которая может «упасть» — к примеру, будет возвращать возраст, принимая дату рождения. Для этого можно было бы использовать `Nothing`, чтобы дать понять программе, что что-то пошло не по плану и использовать ветвление, однако это не слишком информативно. Было бы совсем не лишним знать, что именно пошло не так, давайте попробуем написать это используя `Either`:

```js
const moment = require('moment');

// getAge :: Date -> User -> Either(String, Number)
const getAge = curry((now, user) => {
  const birthDate = moment(user.birthDate, 'YYYY-MM-DD');

  return birthDate.isValid()
    ? Either.of(now.diff(birthDate, 'years'))
    : left('Birth date could not be parsed');
});

getAge(moment(), { birthDate: '2005-12-12' });
// Right(9)

getAge(moment(), { birthDate: 'July 4, 2001' });
// Left('Birth date could not be parsed')
```

Как и в случае с `Nothing`, мы прерываем выполнение, когда возвращаем `Left`, разница в том, что в случае с `Left` сохраняется сообщение об ошибке. Стоит отметить, что функция возвращает `Either(String, Number)`, а именно строку слева, а число справа. Такое определение типа слегка неформально, так как мы так и не реализовали класс `Either`, однако он сообщает, что функция возвращает число, либо сообщение об ошибке.

```js
// fortune :: Number -> String
const fortune = compose(concat('If you survive, you will be '), toString, add(1));

// zoltar :: User -> Either(String, _)
const zoltar = compose(map(console.log), map(fortune), getAge(moment()));

zoltar({ birthDate: '2005-12-12' });
// 'If you survive, you will be 10'
// Right(undefined)

zoltar({ birthDate: 'balloons!' });
// Left('Birth date could not be parsed')
```

Если дата рождения задана корректно, то программа выведет на экран таинственное пророчество, в противном случае мы получим экземляр класса `Left` с сообщением об ошибке внутри контейнера. Логика поведения такая же, как с выбросом исключения, но в более спокойной и взвешенной манере.
