# Хиндли-Милнер и Я

## Какого ты типа?

Если вы новичок в функциональном мире, то пройдет совсем немного времени прежде, чем вы погрузитесь в сигнатуры типов достаточно глубоко. Типы — это метаязык, который позволяет людям с самым различным бэкграундом общаться емко и эффективно. Большинство из них написанны в системе Хиндли-Милнера, которую мы вместе рассмотрим в этой главе.

Когда работаешь с чистыми функциями, сигнатуры типов имеют выразительную мощь, с которой не сравнится никакой естественный язык. Эти сигнатуры шепчут вам о сокровенных секретах функций. В одну простую, компактную строку они вмещают описание поведения и цели функции. Из них мы можем вывести "бесплатные теоремы". Типы могут быть описаны таким образом, что не будет необходимости в явных анотациях. Они могут быть настроены довольно точно или описывать все в общем и абстрактном свете. Они пригодны не только для проверок на этапе компиляции, но также могут служить отличной документацией. Таким образом, сигнатуры типов играют важную роль в функциональном программировании — намного большую, чем вы могли ожидать вначале.

JavaScript — динамический язык, но это не означает, что мы все избегаем типов данных. Мы всё еще работаем со строками, числами, булевским типом и так далее. Просто нет каких-либо средств на уровне языка, так что мы должны держать всё это в голове. Не беспокойтесь, если мы используем сигнатуры для документирования, мы можем заставить комментарии послужить нашим целям.

Доступны утилиты для проверки типов, такие как [Flow](http://flowtype.org/) или даже типизированные диалекты — [TypeScript](http://www.typescriptlang.org/). Целью этой книги является снабжение вас инструментами для написания функционального кода, так что мы будем придерживаться стандартной системы типов используемой в функциональных языках.

## Байки из Скрипта

С пыльных страниц математических томов, сквозь глубокое моге белых листов, посреди обыкновенных записей в блогах по субботним утрам, приближаясь всё ближе к исходному коду, мы находим сигнатуры типов Хиндли-Милнера. Система довольно проста, но гарантирует быстрое объяснение и некоторые практики, которые полностью покрывают небольшой язык.

```js
//  capitalize :: String -> String
var capitalize = function(s){
  return toUpperCase(head(s)) + toLowerCase(tail(s));
}

capitalize("smurf");
//=> "Smurf"
```

Здесь `capitalize` принимет `String` и возвращает тоже `String`. Не думайте о реализации, нас интересует сигнатура типов. 

В системе Хиндли-Милнера функции записываются как `a -> b`, где `a` и `b` — это переменные того или иного типа. Так что сигнатура функции `capitalize` может быть прочтена как "функция из `String` в `String`". Другими словами, она принимает на вход `String` и возвращает `String` в качестве результата.

Давайте посмотрим еще на несколько сигнатур:

```js
//  strLength :: String -> Number
var strLength = function(s){
  return s.length;
}

//  join :: String -> [String] -> String
var join = curry(function(what, xs){
  return xs.join(what);
});

//  match :: Regex -> String -> [String]
var match = curry(function(reg, s){
  return s.match(reg);
});

//  replace :: Regex -> String -> String -> String
var replace = curry(function(reg, sub, s){
  return s.replace(reg, sub);
});
```

В `strLength` та же идея, что и прежде. Мы берем тип `String` и возрвщаем тип `Number`.

Другие примеры могут озадачить на первый взгляд. Без полноценного понимания всех деталей, вы всегда можете видеть последний тип, значения которого и возвращаются. Так что функция `match` может быть интерпретирована так: она берет `Regex` и `String` и возвращает вам `[String]`. Но здесь происходит интересная вещь, и я бы хотел объяснить вам это, если можно.

Для `match` мы можем сгруппировать сигнатуры следуюшим образом:

```js
//  match :: Regex -> (String -> [String])
var match = curry(function(reg, s){
  return s.match(reg);
});
```

Ах да, группировка последней части в круглые скобки предоставляет нам больше сведений. Теперь мы видим ее как функцию, которая принимает `Regex` и возвращает функцию из `String` в `[String]`. Вот что происходит на самом деле из-за каррирования: передвая функции `Regex` мы получаем другую функцию, которая ожидает в качестве аргумента `String`. Конечно, нам не обязательно думать в таком ключе каждый раз, но полезно понимать откуда и как возвращается последний тип.

```js
//  match :: Regex -> (String -> [String])

//  onHoliday :: String -> [String]
var onHoliday = match(/holiday/ig);
```

Каждый аргумент вытасквиается с левого края сигнатуры. `onHoliday` — это `match` у которого уже есть `Regex`.

```js
//  replace :: Regex -> (String -> (String -> String))
var replace = curry(function(reg, sub, s){
  return s.replace(reg, sub);
});
```

Как вы можете видеть, все эти круглые скобки в `replace` являются слегка трудными для чтения и кажутся излишними, так что мы просто опустим их. Мы можем взять все аргументы сразу, если если решим, что проще думать о них так: `replace` принимает  `Regex`, `String`, другой `String` и в конце возвращает `String`.

Еще пару штук, напоследок:

```js
//  id :: a -> a
var id = function(x){ return x; }

//  map :: (a -> b) -> [a] -> [b]
var map = curry(function(f, xs){
  return xs.map(f);
});
```

Функция `id` принимет любой тип `a` и возвращает что-то того же типа `a`. Мы можем использовать переменные любых типов в коде вроде этого. Имена переменных, такие как `a` и `b` — это соглашение, но они произвольны и могут быть заменены на переменные с любым именем, каким вы захотите. Если это одни и те же переменные, то у них должен быть один и тот же тип. Это важное правило, так что давайте повторим: `a` -> `b` — может быть любого типа `a` и любого типа `b`, но `a -> a` означает, что это это один и тот же тип. Например, `id` может быть `String -> String` или `Number -> Number`, но не `String -> Bool`.

Таким же образом `map` использует типизированные переменные, но но в этот раз мы представляем `b` который может быть (а может и не быть) того же типа, что и `a`. Мы можем прочитать это так: `map` принимает функцию из любого типа `a` в такой же тип или в другой тип `b`, затем принимает массив переменных типа `a` и в результате передает массив типов `b`.

Будем надеятся, что вас захватила выразительная красота этой сигнатуры. Она буквально говорит что делает функция, почти слово в слово. Дана функция из `a` в `b`, массив типа `a` и эта функция даст нам массив типа `b`. Единственно здравая вещь, которую должна делать эта функция — это применить кровавую функцию к каждому `a`. Все остальное — гнусная ложь.

Возможность рассуждать о типах и их смысле — это навык, с которым вы далеко пойдете в функциональном мире. Не только статьи, блоги, документации и прочее станет более доступным, кроме того, сами сигнатуры будут полезными анотациями о функциональности. Требуется практика, чтобы свободно читать их, но если вы уделите этому время, то куча информации станет доступна вам без  чтения подробных мануалов.

Вот еще немного, просто чтобы посмотреть, сможете ли вы расшифровать их сами.

```js
//  head :: [a] -> a
var head = function(xs){ return xs[0]; }

//  filter :: (a -> Bool) -> [a] -> [a]
var filter = curry(function(f, xs){
  return xs.filter(f);
});

//  reduce :: (b -> a -> b) -> b -> [a] -> b
var reduce = curry(function(f, x, xs){
  return xs.reduce(f, x);
});
```

Возможно, `reduce` — самый выразительный из них. Он довольно запутан, поэтому не комплексуйте, если вам придётся попотеть.

## Сужение возможностей

После того, как представлен тип переменной, возникает любопытное свойство называемое *параметричностью*[^http://en.wikipedia.org/wiki/Parametricity]. Это свойство говорит, что функция будет *вести себя со всеми типами одинаково*. Давайте рассмотрим:

```js
// head :: [a] -> a
```

Вглядываясь в `head` мы видим как он превращает `[a]` в `a`. Кроме конкретнного типа `array`, не доступно больше никакой информации, следовательно, функциональность ограничена работой только над массивом. Что вообще можно сделать с переменной `a`, если ничего про нее не известно? `a` не говорит о том, что он какого-то *специфичного* типа, напротив, `a` может быть *любого* типа, что оставляет нам функцию, которая должна работать одинаково для *каждого* возможного типа. Это и есть *параметричность*. Задумываясь о реализации, единственно осмысленные допущения — это то, что функция вытаскивает первый, последний, или любой другой элемент из массива. Имя `head` должно подсказать нам, какой именно.

Вот еще одна: 

```js
// reverse :: [a] -> [a]
```

Исходя только из сигнатуры, чем может быть `reverse`? Вновь она не может сделать ничего особенного с `a`. Она не может привести `a` к какому-то другому типу. Может быть сортирует? Что же, нет, недостаточно информации, чтобы сортировать все  возможные типы. Возможно перетасовка? Да, я полагаю она может это сделать, но это должно происходить одинаковым и предсказуемым образом. Другая возможность, о которой я могу подумать, — это удаление или дублирование элемента. В любом случае, суть в том, что возможное поведение функции значительно сужается благодаря разнородности типа.

Это сужение возможностей позволяет нам использовать сигнатуры типов в поисковых движках вроде [Hoogle](https://www.haskell.org/hoogle), чтобы найти функцию. Информация упакованная в сигнатуры — действительно довольно мощное средство.

## Свобода в правилах

Кроме вывода реализации возможностей, этот тип рассужденией дает нам *правила-теоремы, без дополнительных усилий*. Вот несколько случайных примеров прямиком из [работы Уодлера по этой теме](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf).

```js
// head :: [a] -> a
compose(f, head) == compose(head, map(f));

// filter :: (a -> Bool) -> [a] -> [a]
compose(map(f), filter(compose(p, f))) == compose(filter(p), map(f));
```

Вам не нужен какой-либо код, чтобы получить эти правила, они следуют прямо из типов. Первое говорит нам, что если мы имеет `head` для массива, затем применяем некую функцию `f` к ней, то это эквивалентно (и между прочим, намного быстрее) тому, как если бы мы сначала исполнили `map(f)` на кажом элементе массива, а затем бы применили `head` к результату.

Возможно вы думаете, ладно, это всего-лишь здравый смысл. Но в последний раз, когда я проверял, у компьютеров не было здравого смысла. Действительно, они должны иметь формальный способ автоматизировать подобные оптимизации программы. У математики есть средство, чтобы формализовать ход своих мыслей, что помогает продираться свозь жесткую местность компьютерной логики.

Правило для `filter` выглядит знакомым. Оно говорит, что если мы создаем композицию `f` и `p` чтобы вычислить то, что должно быть отфильтрованно, то мы на самом деле применяем `f` с помощью `map` (помните, filter не изменяет элементы, —  его сигнатура принуждает к тому, что `a` не будет тронуто), и это всегда будет эквивалентно тому, что мы преобразуем `f`, а затем отфильтруем результат с помощью предиката `p`.

Здесь просто два примера. Но вы можете применить этот тип рассуждений к любой полиморфной сигнатуре и это будет работать. В JavaScript есть несколько доступных инструментов, чтобы объявлять переиспользуемые правила. Можно также сделать это с помощью функции `compose`. Возможности безграничны.

## В итоге 

Сигнатуры типов Хиндли-Милнера вездесущи в функциональном мире. Хотя они просты для чтения и записи, нужно время чтобы отточить технику понимания программ с помощью одних только сигнатур. С этого момента, мы будем добавлять сигнатуры типов к каждой строке кода. 

[Глава 8: Контейнер](ch8-ru.md)