# Хиндли-Милнер и Я

## Какого ты типа?

Если вы новичок в функциональном мире, то пройдет совсем немного времени прежде, чем вы погрузитесь в сигнатуры типов достаточно глубоко. Типы — это метаязык, который позволяет людям с самым различным бэкграундом общаться емко и эффективно. Большинство из них написаны в системе Хиндли-Милнера, которую мы вместе рассмотрим в этой главе.

Когда работаешь с чистыми функциями, сигнатуры типов имеют выразительную мощь, с которой не сравнится никакой естественный язык. Эти сигнатуры шепчут вам о сокровенных секретах функций. В одну простую, компактную строку они вмещают описание поведения и цели функции. Из них мы можем вывести "бесплатные теоремы". Типы могут быть описаны таким образом, что не будет необходимости в явных аннотациях. Они могут быть настроены довольно точно или описывать все в общем и абстрактном свете. Они пригодны не только для проверок на этапе компиляции, но также могут служить отличной документацией. Таким образом, сигнатуры типов играют важную роль в функциональном программировании — намного большую, чем вы могли ожидать вначале.

JavaScript — динамический язык, но это не означает, что мы все избегаем типов данных. Мы всё еще работаем со строками, числами, булевым типом и так далее. Просто нет каких-либо средств на уровне языка, так что мы должны держать всё это в голове. Не беспокойтесь, если мы используем сигнатуры для документирования, мы можем заставить комментарии послужить нашим целям.

Доступны утилиты для проверки типов, такие как [Flow](http://flowtype.org/) или даже типизированные диалекты — [TypeScript](http://www.typescriptlang.org/). Целью этой книги является снабжение вас инструментами для написания функционального кода, так что мы будем придерживаться стандартной системы типов используемой в функциональных языках.

## Байки из Скрипта

С пыльных страниц математических томов, сквозь глубокое море белых листов, посреди обыкновенных записей в блогах по субботним утрам, приближаясь всё ближе к исходному коду, мы находим сигнатуры типов Хиндли-Милнера. Система довольно проста, но гарантирует быстрое объяснение и некоторые практики, которые полностью покрывают небольшой язык.

```js
//  capitalize :: String -> String
var capitalize = function(s){
  return toUpperCase(head(s)) + toLowerCase(tail(s));
}

capitalize("smurf");
//=> "Smurf"
```

Здесь `capitalize` принимает `String` и возвращает тоже `String`. Не думайте о реализации, нас интересует сигнатура типов. 

В системе Хиндли-Милнера функции записываются как `a -> b`, где `a` и `b` — это переменные того или иного типа. Так что сигнатура функции `capitalize` может быть прочтена как "функция из `String` в `String`". Другими словами, она принимает на вход `String` и возвращает `String` в качестве результата.

Давайте посмотрим еще на несколько сигнатур:

```js
//  strLength :: String -> Number
var strLength = function(s){
  return s.length;
}

//  join :: String -> [String] -> String
var join = curry(function(what, xs){
  return xs.join(what);
});

//  match :: Regex -> String -> [String]
var match = curry(function(reg, s){
  return s.match(reg);
});

//  replace :: Regex -> String -> String -> String
var replace = curry(function(reg, sub, s){
  return s.replace(reg, sub);
});
```

В `strLength` та же идея, что и прежде. Мы берем тип `String` и возвращаем тип `Number`.

Другие примеры могут озадачить на первый взгляд. Без полноценного понимания всех деталей, вы всегда можете видеть последний тип, значения которого и возвращаются. Так что функция `match` может быть интерпретирована так: она берет `Regex` и `String` и возвращает вам `[String]`. Но здесь происходит интересная вещь, и я хотел бы вам её объяснить.

Для `match` мы можем сгруппировать сигнатуры следующим образом:

```js
//  match :: Regex -> (String -> [String])
var match = curry(function(reg, s){
  return s.match(reg);
});
```

Ах да, группировка последней части в круглые скобки предоставляет нам больше сведений. Теперь мы видим ее как функцию, которая принимает `Regex` и возвращает функцию из `String` в `[String]`. Вот что происходит на самом деле из-за каррирования: передавая функции `Regex` мы получаем другую функцию, которая ожидает в качестве аргумента `String`. Конечно, нам не обязательно думать в таком ключе каждый раз, но полезно понимать откуда и как возвращается последний тип.

```js
//  match :: Regex -> (String -> [String])

//  onHoliday :: String -> [String]
var onHoliday = match(/holiday/ig);
```

Каждый аргумент берётся с левого края сигнатуры. `onHoliday` — это `match` у которого уже есть `Regex`.

```js
//  replace :: Regex -> (String -> (String -> String))
var replace = curry(function(reg, sub, s){
  return s.replace(reg, sub);
});
```

Как вы можете видеть, все эти круглые скобки в `replace` являются слегка трудными для чтения и кажутся излишними, так что мы просто опустим их. Мы можем взять все аргументы сразу, если решим, что проще думать о них так: `replace` принимает  `Regex`, `String`, другой `String` и в конце возвращает `String`.

Еще пару штук, напоследок:

```js
//  id :: a -> a
var id = function(x){ return x; }

//  map :: (a -> b) -> [a] -> [b]
var map = curry(function(f, xs){
  return xs.map(f);
});
```

Функция `id` принимает любой тип `a` и возвращает что-то того же типа `a`. Мы можем использовать переменные любых типов в коде вроде этого. Имена переменных, такие как `a` и `b` — это соглашение, но они произвольны и могут быть заменены на переменные с любым именем, каким вы захотите. Если это одни и те же переменные, то у них должен быть один и тот же тип. Это важное правило, так что давайте повторим: `a` -> `b` — может быть любого типа `a` и любого типа `b`, но `a -> a` означает, что это это один и тот же тип. Например, `id` может быть `String -> String` или `Number -> Number`, но не `String -> Bool`.

Таким же образом `map` использует типизированные переменные, но в этот раз мы представляем `b`, который может быть (а может и не быть) того же типа, что и `a`. Мы можем прочитать это так: `map` принимает функцию из любого типа `a` в такой же тип или в другой тип `b`, затем принимает массив переменных типа `a` и в результате передает массив типов `b`.

Будем надеяться, что вас захватила выразительная красота этой сигнатуры. Она буквально говорит что делает функция, почти слово в слово. Дана функция из `a` в `b`, массив типа `a` и эта функция даст нам массив типа `b`. Единственно здравая вещь, которую должна делать эта функция — это применить кровавую функцию к каждому `a`. Все остальное — гнусная ложь.

Возможность рассуждать о типах и их смысле — это навык, с которым вы далеко пойдете в функциональном мире. Не только статьи, блоги, документации и прочее станет более доступным, кроме того, сами сигнатуры будут полезными аннотациями о функциональности. Требуется практика, чтобы свободно читать их, но если вы уделите этому время, то куча информации станет доступна вам без чтения подробных мануалов.

Вот еще немного, просто чтобы посмотреть, сможете ли вы расшифровать их сами.

```js
//  head :: [a] -> a
var head = function(xs){ return xs[0]; }

//  filter :: (a -> Bool) -> [a] -> [a]
var filter = curry(function(f, xs){
  return xs.filter(f);
});

//  reduce :: (b -> a -> b) -> b -> [a] -> b
var reduce = curry(function(f, x, xs){
  return xs.reduce(f, x);
});
```

Возможно, `reduce` — самый выразительный из них. Он довольно запутан, поэтому не комплексуйте, если вам придётся попотеть.

## Сужение возможностей

После того, как представлен тип переменной, возникает любопытное свойство называемое *параметричностью*[^http://en.wikipedia.org/wiki/Parametricity]. Это свойство говорит, что функция будет *вести себя со всеми типами одинаково*. Давайте рассмотрим:

```js
// head :: [a] -> a
```

Вглядываясь в `head` мы видим как он превращает `[a]` в `a`. Кроме конкретного типа `array`, не доступно больше никакой информации, следовательно, функциональность ограничена работой только над массивом. Что вообще можно сделать с переменной `a`, если ничего про нее не известно? `a` не говорит о том, что он какого-то *специфичного* типа, напротив, `a` может быть *любого* типа, что оставляет нам функцию, которая должна работать одинаково для *каждого* возможного типа. Это и есть *параметричность*. Задумываясь о реализации, единственное, что кажется разумным — это то, что функция вытаскивает первый, последний, или любой другой элемент из массива. Имя `head` должно подсказать нам, какой именно.

Вот еще одна: 

```js
// reverse :: [a] -> [a]
```

Исходя только из сигнатуры, чем может быть `reverse`? Вновь, она не может сделать ничего особенного с `a`. Она не может привести `a` к какому-то другому типу. Может быть сортирует? Что же, нет, недостаточно информации, чтобы сортировать все возможные типы. Возможно перетасовка? Да, я полагаю она может это сделать, но это должно происходить одинаковым и предсказуемым образом. Другая возможность, о которой я могу подумать, — это удаление или дублирование элемента. В любом случае, суть в том, что возможное поведение функции значительно сужается благодаря разнородности типа.

Это сужение возможностей позволяет нам использовать сигнатуры типов в поисковых движках вроде [Hoogle](https://www.haskell.org/hoogle), чтобы найти функцию. Информация упакованная в сигнатуры — действительно довольно мощное средство.

## Свобода в правилах

Кроме вывода реализации возможностей, этот тип рассуждений дает нам *правила-теоремы, без дополнительных усилий*. Вот несколько случайных примеров прямиком из [работы Уодлера по этой теме](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf).

```js
// head :: [a] -> a
compose(f, head) == compose(head, map(f));

// filter :: (a -> Bool) -> [a] -> [a]
compose(map(f), filter(compose(p, f))) == compose(filter(p), map(f));
```

Вам не нужен какой-либо код, чтобы получить эти правила, они следуют прямо из типов. Первое говорит нам, что если мы имеем `head` для массива, затем применяем некую функцию `f` к ней, то это эквивалентно (и между прочим, намного быстрее) тому, как если бы мы сначала исполнили `map(f)` на каждом элементе массива, а затем бы применили `head` к результату.

Возможно вы думаете, ладно, это всего лишь здравый смысл. Но, в последний раз когда я проверял, у компьютеров не было здравого смысла. Действительно, они должны иметь формальный способ автоматизировать подобные оптимизации программы. У математики есть средство, чтобы формализовать ход своих мыслей, что помогает продираться сквозь жесткую местность компьютерной логики.

Правило для `filter` выглядит знакомым. Оно говорит, что если мы создаем композицию из `f` и `p`, чтобы отфильтровать необходимое, то на самом деле мы применяем `f` с помощью `map` (помните, что `filter` не меняет элементы, его сигнатура говорит о том, что `a` не будет тронуто), и это всегда эквивалентно преобразованию с помощью `f`, а затем фильтрации результата с помощью предиката `p`.

Это просто два примера. Но вы можете применить этот тип рассуждений к любой полиморфной сигнатуре, и это будет работать. В JavaScript есть несколько доступных инструментов, чтобы объявлять переиспользуемые правила. Можно также сделать это с помощью функции `compose`. Возможности безграничны.

## В итоге 

Сигнатуры типов Хиндли-Милнера вездесущи в функциональном мире. Хотя они просты для чтения и записи, нужно время чтобы отточить технику понимания программ с помощью одних только сигнатур. С этого момента, мы будем добавлять сигнатуры типов к каждой строке кода. 

[Глава 8: Контейнер](ch8-ru.md)
