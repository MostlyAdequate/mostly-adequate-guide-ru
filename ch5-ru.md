# Глава 05: Использование композиции

## Скрещивание функций

Пример `композиции`:

```js
const compose = (...fns) => (...args) => fns.reduceRight((res, fn) => [fn.call(null, ...res)], args)[0];
```

... Don't be scared! This is the level-9000-super-Saiyan-form of _compose_. For the sake of reasoning, let's drop the variadic implementation and consider a simpler form that can compose two functions together. Once you get your head around that, you can push the abstraction further and consider it simply works for any number of functions (we could even prove that)!
Here's a more friendly _compose_ for you my dear readers:

```js
const compose2 = (f, g) => x => f(g(x));
```

`f` и `g` — функции, а `x` — значение, которое «пробрасывается» через них.

Композиция напоминает скрещивание функций. Вы, как биолог, выбираете 2 функции с нужными вам характеристиками и скрещиваете их, чтобы получить новый «вид». Вот как можно использовать функцию `compose`:

```js
const toUpperCase = x => x.toUpperCase();
const exclaim = x => `${x}!`;
const shout = compose(exclaim, toUpperCase);

shout('send in the clowns'); // "SEND IN THE CLOWNS!"
```

Композиция двух функций возвращает новую функцию. В этом есть смысл: композиция двух элементов одного типа (в данном случае функций) должна вернуть новый элемент того же типа. Вы же не ждёте, что соединив две части лего у вас получится матрёшка? Композицией управляет закон, с которым мы познакомимся в своё время.

В нашем определении `compose`, функция `g` выполнится перед `f`. Таким образом, данные передаются в функции справа налево. Этот вариант написания функций читается куда лучше, чем несколько вложенных. Без композиции предыдущий код выглядел бы так:

```js
const shout = x => exclaim(toUpperCase(x));
```

Вместо изнутри наружу, мы читаем код справа налево, что, по-моему, шаг в левом направлении[^ха-ха]. Давайте взглянем на пример, где порядок имеет значение:

```js
const head = x => x[0];
const reverse = reduce((acc, x) => [x].concat(acc), []);
const last = compose(head, reverse);

last(['jumpkick', 'roundhouse', 'uppercut']); // 'uppercut'
```

Функция `reverse` перевернёт массив, а `head` — вернёт его первый элемент. Их композиция представляет из себя рабочую, хотя и не эффективную функцию `last`. В данном случае важен порядок функций в композиции. Мы могли бы определить и версию, которая работала бы слева направо, но мы хотим оставаться строгими в отношении математического определения композиции. Так и есть, наша композиция как будто сошла со страниц учебника по математике. Давайте же посмотрим, какие свойства математической композиции мы можем применить.

```js
// ассоциативность (associativity)
compose(f, compose(g, h)) === compose(compose(f, g), h);
// true
```

Композиция ассоциативна, это значит, что порядок её применения не важен (в случае вложенной композиции). Если, например, мы хотим заменить все символы в строке на заглавные, то мы можем написать:

```js
compose(toUpperCase, compose(head, reverse));

// или
compose(compose(toUpperCase, head), reverse);
```

Так как порядок группировки функций внутри `compose` не важен, результат будет один и тот же. Это свойство позволяет нам написать `compose` с переменным числом аргументов:

```js
// раньше нам пришлось бы написать две композиции, но, так как композиция ассоциативна,
// мы можем передать в `compose` сколько угодно функций и позволить ей решать как сгруппировать их
const arg = ['jumpkick', 'roundhouse', 'uppercut'];
const lastUpper = compose(toUpperCase, head, reverse);
const loudLastUpper = compose(exclaim, toUpperCase, head, reverse);

lastUpper(arg); // 'UPPERCUT'
loudLastUpper(arg); // 'UPPERCUT!'
//=> 'UPPERCUT!'
```

Применение свойства ассоциативности обеспечивает гибкость, при эквивалентном результате. В библиотеках вроде [lodash][lodash-website], [underscore][underscore-website], и [ramda][ramda-website] вы найдёте немного более сложное определение композиции функции многих переменных, это нормально.

Одним из приятных аспектов композиции является то, что из любого набора функций можно сделать композицию. Давайте поиграемся с рефакторингом предыдущего примера:

```js
const loudLastUpper = compose(exclaim, toUpperCase, head, reverse);

// или
const last = compose(head, reverse);
const loudLastUpper = compose(exclaim, toUpperCase, last);

// или
const last = compose(head, reverse);
const angry = compose(exclaim, toUpperCase);
const loudLastUpper = compose(angry, last);

// и ещё множество вариантов...
```

Мы просто соединяем части лего так, как мы того хотим, здесь нет какого-либо правильного или не правильного подхода. Обычно, лучше группировать функции так, чтобы их можно было переиспользовать, как `last` и `angry`. Если вы знакомы с Рефаторингом Фаулера «[Refactoring][refactoring-book]», вы можете узнать этот процесс как извлечение функции (ранее - извлечение метода) «[extract function][extract-function-refactor]», за исключением того, что в нашем случае нет состояния объекта, о котором пришлось бы беспокоиться.

## Отсутствие ссылок (Pointfree)

Под отсутствием ссылок я подразумеваю стиль написания кода, при котором мы никогда не ссылаемся на данные. Прошу прощения, я имел в виду функции, которые никогда не упоминают данные, над которыми работают. Для написания кода в таком стиле нам пригодятся функции первого класса, каррирование и композиция.

```js
// не в стиле отсутствия ссылок, так как мы упоминаем данные: word
const snakeCase = word => word.toLowerCase().replace(/\s+/ig, '_');

// в стиле отсутствия ссылок
const snakeCase = compose(replace(/\s+/ig, '_'), toLowerCase);
```

Заметили, как мы частично применили `replace`? Здесь мы передаём данные от функции к функции, каждая из которых принимает по 1 аргументу. Каррирование позволяет нам подготовить каждую функцию так, чтобы она принимала нужные ей данные, проводила с ними операции и передавала их дальше. Хочу также отметить, что во втором примере нам не нужны данные, чтобы сконструировать нашу функцию, тогда как в первом примере нам требуется `word`, чтобы сделать хоть что-то.

Давайте взглянем на ещё один пример.

```js
// не в стиле отсутствия ссылок, так как мы упоминаем данные: name
const initials = name => name.split(' ').map(compose(toUpperCase, head)).join('. ');

// в стиле отсутствия ссылок
// NOTE: we use 'intercalate' from the appendix instead of 'join' introduced in Chapter 09!
const initials = compose(intercalate('. '), map(compose(toUpperCase, head)), split(' '));

initials("hunter stockton thompson");
// 'H. S. T'
```

Код, написанный в стиле отсутствия ссылок, остаётся кратким и общим, а также позволяет избавиться от ненужных имён. Код в таком стиле является лакмусовой бумажкой для функционального кода, позволяющей нам оценить, действительно ли мы пишем небольшие функции, отображающие входные данные на выходные. К примеру, написать цикл `while` с использованием композиции не получится. Однако, имейте в виду, что такой код — это всегда палка о двух концах: иногда он может замаскировать намерения. Не весь функциональный код написан в стиле отсутствия ссылок и это нормально. Мы будем стараться писать так, когда можем, в других случаях будем пользоваться обычными функциями.

## Дебаггинг

Частой ошибкой является попытка использовать композицию с функцией двух аргументов вроде `map`, забыв сперва частично применить её:

```js
// не верно — мы передаём массив в функцию angry и бог знает что в map
const latin = compose(map, angry, reverse);

latin(['frog', 'eyes']); // ошибка

// правильно — в каждую функцию передаётся по одному аргументу
const latin = compose(map(angry), reverse);

latin(['frog', 'eyes']); // ['EYES!', 'FROG!'])
```

Если у вас возникнут проблемы с отладкой композиций, то вы можете воспользоваться следующей полезной (хотя и не чистой) функцией.

```js
const trace = curry((tag, x) => {
  console.log(tag, x);
  return x;
});

const dasherize = compose(
  join('-'),
  toLower,
  split(' '),
  replace(/\s{2,}/ig, ' '),
);

dasherize('The world is a vampire');
// TypeError: Cannot read property 'apply' of undefined
```

Что-то здесь не так, давайте воспользуемся `trace`:

```js
const dasherize = compose(
  join('-'),
  toLower,
  trace('after split'),
  split(' '),
  replace(/\s{2,}/ig, ' '),
);

dasherize('The world is a vampire');
// after split [ 'The', 'world', 'is', 'a', 'vampire' ]
```

Точно! Нам нужно обернуть `toLower` в `map`, так как мы имеем дело с массивом.

```js
const dasherize = compose(
  join('-'),
  map(toLower),
  split(' '),
  replace(/\s{2,}/ig, ' '),
);

dasherize('The world is a vampire'); // 'the-world-is-a-vampire'
```

Функция `trace` позволяет нам в целях отладки вывести данные в консоль. Для упрощения разработки, похожие функции уже реализованы в стандартных библиотеках таких языков как Haskell и Purescript.

Композиция послужит нам хорошим инструментом, и хорошо, что она стоит на фундаменте серьёзной теории, которая гарантирует, что она будет работать. Давайте поговорим об этой теории.

## Теория категорий

Теория категорий — это абстрактный раздел математики, который формализует понятия из других разделов, таких как: теория множеств, теория типов, теория групп, логика и других. В первую очередь в теории категорий рассматриваются объекты, морфизмы и отображения, эти понятия довольно точно дублируются и в программировании. Ниже представлена таблица одинаковых понятий из разных теорий.

<img src="images/cat_theory_ru.png" alt="теория категорий" />

Прошу прощения, я не хотел вас испугать. Я не ожидаю того, что вы тщательно разбираетесь в каждой из теорий, представленных выше. Этой иллюстрацией я хотел всего лишь показать, как много понятий дублируются между различными теориями и почему теория категорий стремится их объединить.

В теории категорий мы оперируем понятием... категории. Категория определяется как коллекция со следующими свойствами:

  * коллекция объектов
  * коллекция морфизмов
  * для пары морфизмов определена композиция
  * для каждого объекта задан тождественный морфизм

Теория категорий достаточно абстрактна, чтобы смоделировать многие вещи, однако давайте применим её к тому, что волнует нас больше всего: к типам и функциям.

**Коллекция объектов**

Объектами будут типы данных, такие как: ``String``, ``Boolean``, ``Number``, ``Object``. Мы часто рассматриваем тип данных как набор возможных значений, например, тип данных ``Boolean`` как множество значений `[true, false]` или ``Number`` как множество всех возможных числовых значений. Такой подход будет как нельзя кстати для применения теории множеств.

**Коллекция морфизмов**

Морфизмами будут наши любимые чистые функции.

**Для пары морфизмов определена композиция**

Как вы могли догадаться, здесь речь пойдёт о новомодной `композиции`. Не случайно мы обсуждали, что наша функция `compose` ассоциативна, так как это свойство любой композиции в теории категорий.

Демонстрация работы композиции:

<!-- Или композиция в категории? -->
<img src="images/cat_comp1.png" alt="композиция 1" />
<img src="images/cat_comp2.png" alt="композиция 2" />

Пример композиции в коде:

```js
const g = x => x.length;
const f = x => x === 4;
const isFourLetterWord = compose(f, g);
```

**Для каждого объекта задан тождественный морфизм**
Давайте объявим функцию `id`, которая будет принимать аргумент и просто возвращать его:

```js
const id = x => x;
```

Вы можете задать вопрос: «На кой чёрт вообще нужна эта функция?». Мы будем часто пользоваться этой функцией в будущих главах, а пока просто воспринимайте её как замену значения — функцию, маскирующуюся под обычные данные.

Функция `id` хорошо сочетается с композицией. Вот вам свойство, которое работает для каждой унарной (от одного аргумента) функции f:

```js
// тождество (identity)
compose(id, f) === compose(f, id) === f;
// true
```

Напоминает свойство равенства обычных чисел, не правда ли? Если вам сразу так не показалось — ничего страшного, возьмите небольшую паузу, вы поймёте позже. Скоро мы будем повсюду видеть `id`, но пока что мы видим `id` как функцию-замену значению. Это свойство удобно для написания кода в стиле отсутствия ссылок.

Вот краткое описание теории категорий типов и функций. Если вы познакомились с ней впервые, то, полагаю, вам ещё не до конца ясно что такое категория и чем она может быть полезна, не волнуйтесь, в продолжение этой книги мы копнём глубже. На данный момент, в этой главе, на этой строке, теория категорий по крайней мере подарила нам свойства ассоциативности и тождества.

Какие ещё есть категории? Например, мы можем объявить категорию для направленных графов, где вершины — это объекты, рёбра — морфизмы, а композиция — просто конкатенация пути по графу. Допустим, числа — объекты, а `>=` морфизмы[^вообще, любая дробная или целая степень может быть категорией]. Категорий на самом деле целая куча, но для целей этой книги нас будет интересовать только определённая выше категория. Для начала мы узнали достаточно и можем двигаться дальше.

## Итог

Композиция соединяет наши функции вместе как набор труб, данные «протекают» через наше приложение так как должны — чистые функции отображают входные данные на значения, поэтому разрыв в этой цепи вызовет потерю выходного значения и всё наше приложение станет бесполезным.

Принцип композиции является важнейшим среди прочих, так как помогает сохранять наше приложение простым и логичным. Теория категорий сыграет главную роль в архитектуре приложения, моделировании побочных эффектов и безошибочности работы приложения.

Самое время опробовать наши знания на практике, давайте напишем приложение.

[Глава 06: Пример приложения](ch6-ru.md)

## Упражнения

In each following exercise, we'll consider Car objects with the following shape:

```js
{
  name: 'Aston Martin One-77',
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}
```

### Упражнение A

Используйте `compose()` для того чтобы переписать функцию.
  
```js  
const isLastInStock = (cars) => {  
  const lastCar = last(cars);  
  return prop('in_stock', lastCar);  
};  
```  

### Упражнение B

Considering the following function:

```js
const average = xs => reduce(add, 0, xs) / xs.length;
```

Bспользуйте функцию `average` для того чтобы отрефакторить `averageDollarValue` с помощью композиции
  
```js  
const averageDollarValue = (cars) => {  
  const dollarValues = map(c => c.dollar_value, cars);  
  return average(dollarValues);  
};  
```  

### Упражнение C

Отрефакторьте в стиле отсутствия ссылок. Подсказка: вы можете использовать _.flip()
  
```js  
const fastestCar = (cars) => {  
  const sorted = sortBy(car => car.horsepower);  
  const fastest = last(sorted);  
  return concat(fastest.name, ' is the fastest');  
};  
```  

[lodash-website]: https://lodash.com/
[underscore-website]: http://underscorejs.org/
[ramda-website]: http://ramdajs.com/
[refactoring-book]: http://martinfowler.com/books/refactoring.html
[extract-function-refactor]: https://refactoring.com/catalog/extractFunction.html
