# Глава 1: О чём вообще пойдёт речь?

## Вступление

Привет! Позвольте представиться, меня зовут профессор Франклин Ризби и я собираюсь обучить вас основам функционального программирования. Но хватит уже обо мне, давайте поговорим о вас! Надеюсь, вы знакомы с языком JavaScript и имеете хотя бы небольшой опыт в объектно-ориентированном программировании. Вам не обязательно быть доктором биологических наук, но навык находить и устранять баги вам пригодится.

Я не стану ожидать от вас знания функционального программирования, потому что мы оба знаем, что обычно происходит с ожиданиями. Однако, я надеюсь, что вы попадали в неприятные ситуации, связанные с изменяемым состоянием, неограниченными побочными эффектами и непродуманным дизайном программ.

Теперь, когда мы закончили со знакомством, предлагаю приступить к делу.

Цель этой главы — показать истинную цель, лежащую в основе функционального программирования. Мы должны понять, что именно делает программу *функциональной*. Иначе мы просто будем писать код, отчаянно избегая объектов любой ценой, — довольно неуклюжая идея. Нам понадобится идеал, к которому мы будем стремиться, некий компас, укажущий направление.

Как вы знаете, существует ряд общих принципов программирования, набор аббревиатур, направляющих нас в процессе работы над любым приложением: DRY (don't repeat yourself — не повторяйся), слабое связывание сильное единство (loose coupling high cohesion), YAGNI (ya ain't gonna need it — тебе это не понадобится), принцип наименьшей неожиданности (principle of least surprise), принцип единственной обязанности (single responsibility) и так далее.

Я не стану перечислять каждую аббревиатуру и руководство, которое я встречал за последние годы... Все они имеют отношение и к функциональному программированию, но к нашей цели они относятся слабо. Сейчас я бы хотел донести до вас мой замысел: машинально стучать по клавиатуре — это не для нас, мы стремимся к высшей цели — к функциональной Нирване. 

<!--BREAK-->

## Краткое знакомство

Давайте начнём с немного безумного примера. Ниже вы увидите приложение «чайка». Определим два понятия: объединение стай и размножение. Когда стаи чаек объединяются, их количество складывается, а когда размножаются — умножается. 

Я не претендую на хороший объектно-ориентированный код, он здесь только для того чтобы подчеркнуть минусы современного подхода "присваивания". Держитесь крепче:

```js
var Flock = function(n) {
  this.seagulls = n;
};

Flock.prototype.conjoin = function(other) {
  this.seagulls += other.seagulls;
  return this;
};

Flock.prototype.breed = function(other) {
  this.seagulls = this.seagulls * other.seagulls;
  return this;
};

var flock_a = new Flock(4);
var flock_b = new Flock(2);
var flock_c = new Flock(0);

var result = flock_a.conjoin(flock_c)
    .breed(flock_b).conjoin(flock_a.breed(flock_b)).seagulls;
//=> 32
```
Кто вообще мог сотворить такую мерзкую пакость? Неимоверно трудно уследить за меняющимся внутренним состоянием, и, более того, ответ неправильный! Должно было получиться `16`, но `flock_a` была цинично изменена прямо в процессе. Бедняжка `flock_a`. Это какая-то анархия в ИТ! Дикая животная арифметика!

Если вы не поняли этого кода, ничего страшного, я тоже не понял. Мораль в том, что трудно отследить состояние и изменяющиеся значения переменных даже в таком небольшом примере.

Давайте попробуем более функциональный подход:

```js
var conjoin = function(flock_x, flock_y) { return flock_x + flock_y };
var breed = function(flock_x, flock_y) { return flock_x * flock_y };

var flock_a = 4;
var flock_b = 2;
var flock_c = 0;

var result = conjoin(
  breed(flock_b, conjoin(flock_a, flock_c)), breed(flock_a, flock_b)
);
//=>16
```

На этот раз ответ получился правильный, к тому же, мы написали гораздо меньше кода (хотя и вложенность функций немного сбивает с толку[^мы справимся с этой проблемой в главе 5]). Уже лучше, но давайте копнём ещё глубже. Вы могли обратить внимание, что на самом деле мы работаем с обычным сложением (`conjoin`) и умножением (`breed`).

И правда, в этих функциях нет ничего особенного, кроме их имён. Давайте же переименуем их, чтобы название отражало содержание.

```js
var add = function(x, y) { return x + y };
var multiply = function(x, y) { return x * y };

var flock_a = 4;
var flock_b = 2;
var flock_c = 0;

var result = add(
  multiply(flock_b, add(flock_a, flock_c)), multiply(flock_a, flock_b)
);
//=>16
```

Вспомним школьную арифметику:

```js
// сочетательное свойство
add(add(x, y), z) == add(x, add(y, z));

// переместительное свойство
add(x, y) == add(y, x);

// свойство нейтрального элемента
add(x, 0) == x;

// распределительное свойство
multiply(x, add(y,z)) == add(multiply(x, y), multiply(x, z));
```

Старые добрые математические свойства пришлись здесь как нельзя кстати, не так ли? Не страшно, если вы не смогли их все сразу вспомнить, многие из нас годами никак не использовали эту информацию. Давайте попробуем применить эти свойства, чтобы упростить нашу программу.

```js
// Первоначальный вариант
add(multiply(flock_b, add(flock_a, flock_c)), multiply(flock_a, flock_b));

// Применим свойство нейтрального элемента (напоминаю: `flock_c == 0`)
// (add(flock_a, flock_c) == flock_a)
add(multiply(flock_b, flock_a), multiply(flock_a, flock_b));

// Применим распределительное свойство и получим:
multiply(flock_b, add(flock_a, flock_a));
```

Прекрасно! Нам не понадобилось написать ни строчки кода, только вызвать наши функции. Я включил тела функций `add` и `multiply` в код для полноты, но на самом деле они здесь не нужны, ведь мы можем использовать стороннюю библиотеку, где эти функции уже точно есть.

Вы можете подумать: «очень хитро с твоей стороны привести такой математический пример». Или «реальные программы не такие простые и всё вышесказанное к ним не применимо». Я выбрал этот пример, потому что большинство из нас уже знакомы со сложением и умножением, чтобы было легко понять, как математика может помочь нам при программировании.

Не отчаивайтесь! Для написания приложений, в этой книге мы воспользуемся теориями категорий и множеств, лямбда-исчислением. Все эти методы помогут нам достичь той же простоты, что и в примере с чайками. Вам вовсе не надо быть математиком, чтобы понять примеры из этой книги. На самом деле это почти то же самое, что и использовать обычный фреймворк или API.

Возможно вас удивит то, что можно писать прикладные приложения с применением функционального подхода, аналогичного примеру выше. Короткие программы с понятными свойствами, о которых легко рассуждать и просто анализировать. Программы, которые не изобретают велосипед через строчку. Отсутствие чётких законов может быть полезным, если вы преступник, но в этой книге мы будем учиться прислушиваться и следовать строгим законам математики.

Мы хотим пользоваться теорией, в которой все части идеально складываются вместе, как пазл. Мы хотим описывать прикладные задачи в терминах обобщённых взаимозаменяемых частей и исследовать их свойства для извлечения максимальной пользы. Это потребует немного больше дисциплины, чем подход «и так сойдёт» императивного программирования [^Я дам точное определение императивного подхода позже в этой книге, но на данный момент это всё, что не является функциональным]. Тем не менее, результат работы в контексте жёстких математических рамок вас поразит.

Мы уже заметили мерцание нашей функциональной Полярной звезды где-то вдалеке, но перед тем как мы начнем наше путешествие, нам нужно освоить ещё несколько базовых концепций.

[Глава 2: Функции первого класса](ch2-ru.md)
