# Глава 1: О чём вообще пойдёт речь?

## Вступление

Привет! Позвольте представиться, меня зовут профессор Франклин Ризби и я собираюсь обучить вас основам функционального программирования. Но хватит уже обо мне, давайте поговорим о вас! Надеюсь, вы хотя бы немного знакомы с языком JavaScript и имеете небольшой опыт в объектно-ориентированном программировании. Вам не обязательно быть доктором биологических наук, но навык находить и устранять баги вам пригодится.

Я не стану ожидать от вас знания функционального программирования, потому что мы оба знаем, что обычно происходит с ожиданиями. Однако, я надеюсь, что вы попадали в неприятные ситуации, связанные с изменяемым состоянием, неограниченными побочными эффектами и непродуманным дизайном программ. Теперь, когда мы закончили со знакомством, предлагаю приступить к делу.

Цель этой главы — дать вам представление о том, к чему мы стремимся, когда пишем функциональные программы. Для того, чтобы понимать следующие главы, мы должны понять, что именно делает программу *функциональной*. Иначе мы просто будем писать код, отчаянно избегая объектов любой ценой, — довольно неуклюжая идея. Нам понадобится идеал, к которому мы будем стремиться, некий компас, указывающий направление.

Как вы знаете, существует ряд общих принципов программирования, набор аббревиатур, направляющих нас в процессе работы над любым приложением: DRY (don't repeat yourself — не повторяйся), YAGNI (ya ain't gonna need it — тебе это не понадобится), слабая связанность сильное зацепление (loose coupling high cohesion), принцип наименьшей неожиданности (principle of least surprise), принцип единственной ответственности (single responsibility) и так далее.

Я не стану перечислять каждую аббревиатуру и руководство, которое я встречал за последние годы... Все они имеют отношение и к функциональному программированию, но к нашей конечной цели они относятся слабо. Что я бы хотел чтобы вы прочувствовали сейчас, перед тем как мы двинемся дальше, так это замысел, который предшествует кодированию - нашу функциональную идиллию.

<!--BREAK-->

## Краткая встреча

Давайте начнём с немного безумного примера. У нас есть приложение «чайка». Определим два понятия: объединение стай и размножение. Когда стаи чаек объединяются (conjoin), их количество складывается, а когда размножаются (breed) — умножается. Этот пример не следует рассматривать как хороший объектно-ориентированный код, он нужен здесь для того, чтобы подчеркнуть опасности современного подхода, основанного на "присваивании". Смотрите:

```js
class Flock {
  constructor(n) {
    this.seagulls = n;
  }

  conjoin(other) {
    this.seagulls += other.seagulls;
    return this;
  }

  breed(other) {
    this.seagulls = this.seagulls * other.seagulls;
    return this;
  }
}

const flockA = new Flock(4);
const flockB = new Flock(2);
const flockC = new Flock(0);
const result = flockA
  .conjoin(flockC)
  .breed(flockB)
  .conjoin(flockA.breed(flockB))
  .seagulls;
// 32
```

Кто вообще мог сотворить такую мерзкую пакость? Неразумно трудно уследить за мутирующим (изменяющимся) внутренним состоянием, и, более того, ответ неправильный! Должно было получиться `16`, но `flockA` был цинично изменен прямо в процессе. Бедняжка `flockA`. Это какая-то анархия в ИТ! Дикая животная арифметика!

Если вы не поняли код этой программы, ничего страшного, я тоже не понял. Запомнить стоит то, что за состоянием и мутабельными (изменяемыми) значениями трудно проследить, даже в таком небольшом примере.

Давайте попробуем ещё раз, применив более функциональный подход:

```js
const conjoin = (flockX, flockY) => flockX + flockY;
const breed = (flockX, flockY) => flockX * flockY;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    conjoin(breed(flockB, conjoin(flockA, flockC)), breed(flockA, flockB));
// 16
```

На этот раз мы получили правильный ответ. С гораздо меньшим количеством кода. Вложенность функций немного запутывает... (мы исправим эту ситуацию в главе 5). Уже лучше, но давайте копнём ещё немного глубже. Есть польза в том, чтобы называть вещи своими именами. Если мы взглянем критически на наши функции, то обнаружим, что работаем не более чем с обычным сложением (`conjoin`) и умножением (`breed`).

И правда, в этих функциях нет ничего особенного, кроме их имён. Давайте переименуем их в `multiply` и `add`, чтобы название отражало суть.

```js
const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));
// 16
```
А поскольку теперь мы имеем дело с арифметикой, мы можем применять древние знания:

```js
// сочетательное свойство (associative)
add(add(x, y), z) == add(x, add(y, z));

// переместительное свойство (commutative)
add(x, y) == add(y, x);

// свойство нейтрального элемента (identity)
add(x, 0) == x;

// распределительное свойство (distributive)
multiply(x, add(y, z)) == add(multiply(x, y), multiply(x, z));
```

Старые добрые математические свойства оказались весьма полезны. Не страшно, если вы не смогли их все сразу вспомнить, многие из нас годами никак не использовали эти законы арифметики. Давайте попробуем применить эти свойства, чтобы упростить нашу программу.

```js
// Первоначальный вариант
add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));

// Применим свойство нейтрального элемента (напоминаю: `flockС == 0`)
// (add(flockA, flockC) == flockA)
add(multiply(flockB, flockA), multiply(flockA, flockB));

// Применим распределительное свойство и получим:
multiply(flockB, add(flockA, flockA));
```

Прекрасно! Нам не понадобилось написать ни строчки кода, только вызвать наши функции. Мы включили определения функций `add` и `multiply` в код для полноты, но писать их самостоятельно не нужно - мы можем использовать стороннюю библиотеку, где функции `add` и `multiply` уже точно есть.

Вы можете подумать: «очень хитро с твоей стороны привести такой математический пример». Или «реальные программы не такие простые и подобные рассуждения к ним не применимы». Я выбрал этот пример, потому что большинство из нас уже знакомы со сложением и умножением, поэтому легко понять, насколько математика оказывается полезна нам в программировании.

Не отчаивайтесь - в этой книге мы воспользуемся теорией категорий, теорией множеств и лямбда-исчислением и напишем примеры, применимые к реальному миру, которые достигнут той же элегантной простоты, что и в примере с чайками. Вам также не потребуется быть математиком.
Это будет так же естественно и легко, как использовать обычный фреймворк или API.

Возможно, для вас прозвучит удивительно, что можно писать прикладные приложения с применением функционального подхода, аналогичного примеру выше. Короткие программы с понятными свойствами, о которых легко рассуждать и просто анализировать. Программы, которые не изобретают велосипед через каждую строчку. Отсутствие чётких законов может быть полезным, если вы преступник, но в этой книге мы захотим признать и следовать строгим законам математики.

Мы захотим использовать теорию, в которой каждая часть идеально дополняет остальные. Мы захотим представлять конкретную прикладную задачу как состоящую из универсальных частей, чтобы затем максимально использовать их свойства. Это потребует немного больше дисциплины, чем подход «и так сойдёт» императивного программирования (я дам точное определение императивного подхода позже в этой книге, а пока считайте, что это всё, что за пределами функционального программирования). Выгода от работы в жёстких математических рамках действительно поразит вас.

Мы уже заметили мерцание нашей функциональной Полярной звезды где-то вдалеке, но перед тем как мы начнем наше путешествие, нам нужно освоить ещё несколько базовых концепций.

[Глава 02: Функции первого класса](ch2-ru.md)
