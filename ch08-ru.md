# Глава 08: Контейнеры

## Могучий контейнер

<img src="images/jar.jpg" alt="http://blog.dwinegar.com/2011/06/another-jar.html" />

Мы разобрались, как писать программы, которые передают данные через ряд чистых функций. Программы, которые представляют собой декларативное описание поведения. Но что насчёт потока управления, обработки ошибок, асинхронных действий, состояния и, осмелюсь спросить, эффектов? В этой главе мы изучим основу для воплощения всех этих полезных абстракций.

Для начала мы создадим контейнер. Этот контейнер должен быть универсальным и позволять содержать любой тип значения (потому что, к примеру, контейнер для пудинга из тапиоки пригодится лишь изредка). Это будет объект, но мы не станем наделять его свойствами и методами в том смысле, который стоит за свойствами и методами в ООП. Вместо этого, мы будем относиться к нему, как к шкатулке с сокровищами — специальной коробке, которая хранит наши ценные данные.

```js
class Container {
  constructor(x) {
    this.$value = x;
  }
  
  static of(x) {
    return new Container(x);
  }
}
```

Вот наш первый контейнер. Мы глубокомысленно назвали его «Контейнер». Мы будем использовать `Container.of` в качестве конструктора, что избавит нас от необходимости повсеместно использовать это ужасное ключевое слово `new`. На самом деле, за использованием функции `of` стоит нечто большее, чем кажется на первый взгляд, но всему своё время, а пока считайте её надлежащим способом помещать значение в наш контейнер.

Давайте испытаем получившуюся банку...

```js
Container.of(3);
// Container(3)

Container.of('hotdogs');
// Container("hotdogs")

Container.of(Container.of({ name: 'yoda' }));
// Container(Container({ name: 'yoda' }))
```

Если вы используете **node**, вы увидите `{$value: x}`, хотя мы объявляли `Container(x)`. Chrome отобразит название правильно, но это не важно для нас; пока мы понимаем, что из себя представляет «Контейнер», всё будет в порядке. В некоторых средах вы можете переопределить метод `inspect`, если хотите, но мы не будем сейчас настолько дотошными. В этой книге мы будем обозначать возвращаемое значение условно, как если бы мы на самом деле переопределили `inspect`, потому что `Container(x)` — гораздо более наглядно, чем `{$value: x}`, и полезно с педагогической точки зрения.

Прежде чем продолжить, давайте проясним несколько моментов:

* `Container` — это объект с одним полем. Наш контейнер, как и множество других, содержит только одну вещь, но это ограничение характерно не для всех контейнеров. Мы произвольно назвали это свойство `$value`.

* тип `$value` не должен быть ограничен одним конкретным типом, иначе наш `Container` утратит универсальность и вряд ли будет соответствовать названию.

* будучи помещённым в «Контейнер», значение остаётся там насовсем. Мы *могли бы* получать доступ к ним, используя `.$value`, но такая практика только отдаляет нас от целей, ради которых создаются контейнеры.

Причины, по которым мы устанавливаем для контейнеров именно такие условия, скоро прояснятся — потерпите немного.

## Мой первый функтор

Раз мы поместили значение *(каким бы оно ни было)* в контейнер, нам потребуется способ применения функций к нему.

```js
// (a -> b) -> Container a -> Container b
Container.prototype.map = function (f) {
  return Container.of(f(this.$value));
};
```

Выглядит подобно функции `map`, определённой для массивов, только вместо `[a]` наша `map` определена для `Container a`. Работает так же:

```js
Container.of(2).map(two => two + 2); 
// Container(4)

Container.of('flamethrowers').map(s => s.toUpperCase()); 
// Container('FLAMETHROWERS')

Container.of('bombs').map(append(' away')).map(prop('length')); 
// Container(10)
```

Стоит отметить важную вещь: мы можем работать со значением, не извлекая его из контейнера. Посредством `map` значение передаётся в функцию-отображение, что позволяет нам повозиться с ним; и сразу же возвращается на своё место, в `Container`. А поскольку в результате мы снова получаем `Container` *(значения не покидают его просто так)*, мы снова можем использовать `map`, чтобы продолжить применять функции. Можем также по мере продолжения изменить тип значения, как демонстрирует третий пример.

Подождите-ка — если мы продолжаем применять `map`, выходит, что у нас получилась композиция! Что это ещё за математическая магия? Что ж, мы только что открыли для себя **Функторы**.

> Функтор — это класс типов, для которых определена `map` и выполняются некоторые законы 

*(То есть, функтор — это не какой-то конкретный тип, но конкретный тип может являться функтором при выполнении условий. За выполнением законов для каждой конкретной реализации `map` должен проследить её разработчик, они сами себя не выполнят — прим. пер.).*

Да, *Functor* — это нечто вроде интерфейса с контрактом, мы легко могли бы назвать его *Mappable*, но какой в этом *fun*?. Функторы определяются в теории категорий, и мы познакомимся с их математическим смыслом ближе к концу этой главы, а сейчас давайте сделаем так, чтобы использование этого интерфейса с причудливым названием стало для нас интуитивно понятным.

Какая причина должна заставить нас запрятать значение в контейнер, чтобы потом использовать `map`, добираясь до него? Ответ прояснится, если мы подберём более подходящий вопрос: что мы получим, если станем просить наш контейнер применять функции за нас? Получим абстракцию применения функции. Когда мы используем `map`, мы просим контейнер применить функцию-отображение к значению *(и сделать это так, как определено для конкретного вида контейнера)*. На самом деле, это очень важная концепция.

## Maybe Шрёдингера

<img src="images/cat.png" alt="cool cat, need reference" />

Функтор `Container` — довольно скучный. На самом деле, обычно он называется `Identity` и у него примерно та же роль, что и у функции `id` (и снова, между ними существует математическая связь, которую мы рассмотрим в своё время). Однако существуют и другие функторы *(типы, подобные контейнеру)*, которые реализуют `map`, предоставляющую какое-либо особенное поведение при отображении (и, разумеется, также соблюдающую законы). Давайте определим такой прямо сейчас.

> Более полная реализация приведена в [Приложении B](./appendix_b-ru.md#Maybe)

```js
class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  constructor(x) {
    this.$value = x;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  inspect() {
    return this.isNothing ? 'Nothing' : `Just(${inspect(this.$value)})`;
  }
}
```

`Maybe` похож на `Container`, к которому добавлена особенность: перед тем, как применить функцию к значению, `map` проверит его наличие. Такое поведение позволяет избежать раздражающих неудобств в случаях, когда вместо ожидаемого значения функция применяется к `null` или `undefined` (обратите внимание: реализация упрощена для того, чтобы сохранить объяснение простым).


```js
Maybe.of('Malkovich Malkovich').map(match(/a/ig));
// Just(True)

Maybe.of(null).map(match(/a/ig));
// Nothing

Maybe.of({ name: 'Boris' }).map(prop('age')).map(add(10));
// Nothing

Maybe.of({ name: 'Dinah', age: 14 }).map(prop('age')).map(add(10));
// Just(24)
```

Обратите внимание: наше приложение не взрывается с ошибками в случаях, когда мы пытаемся применить функции к `null`. Это возможно благодаря тому, что `Maybe` возлагает на себя обязанность следить за доступностью значения всякий раз, когда применяет функцию.

Обращение к `map` через `.` не делает код менее функциональным, и в нём нет ничего предосудительного. Однако по причинам, которые перечислены в первой части книги, нам стоит продолжить придерживаться бесточечного стиля. К тому же, имеющаяся у нас 'map' готова делегировать применение функций любому функтору, с которым будет иметь дело:

```js
// map :: Functor f => (a -> b) -> f a -> f b
const map = curry((f, anyFunctor) => anyFunctor.map(f));
```

Замечательно! Мы можем продолжать использовать композицию, и `map` будет работать ожидаемо. Это справедливо и для `map` из библиотеки **ramda**. Мы будем использовать `.` для случаев, где это способствует пониманию, и бесточечный стиль там, где это удобно. Кстати, вы заметили? Я ввёл новые обозначения в сигнатуру типа. `Functor f =>` говорит нам, что `f` должен быть функтором. Это несложно, но об этом стоило упомянуть.

## Примеры использования

На практике мы обычно будем встречать `Maybe` в таких функциях, для которых вычисление результата возможно не всегда.

```js
// safeHead :: [a] -> Maybe(a)
const safeHead = xs => Maybe.of(xs[0]);

// streetName :: Object -> Maybe String
const streetName = compose(map(prop('street')), safeHead, prop('addresses'));

streetName({ addresses: [] });
// Nothing

streetName({ addresses: [{ street: 'Shady Ln.', number: 4201 }] });
// Just('Shady Ln.')
```

`safeHead` подобна знакомой нам `head`, но безопасная на уровне типов. Любопытная вещь происходит, когда в коде используется `Maybe` — ведь, так или иначе, в отдельных случаях мы будем вынуждены сталкиваться с неудобными значениями `null` и `undefined` *(которые по замыслу должны обозначать неопределённость, но приводят к поломкам, потому что используются неожиданно и неочевидно)*. Но функция `safeHead` честна с нами в отношении такой неопределённости, и она возвращает `Maybe`, чтобы мы тоже принимали неопределённость во внимание. При этом мы не просто *информированы* — нам *придётся* использовать `map`, чтобы продолжать работать со значением, пока оно скрыто за `Maybe`. В данном случае ответственность за проверку на `null` возложено на саму функцию `safeHead`, и мы можем не возлагать ответственность за проверку значений `head` в остальных частях приложения *(что избыточно и противоречит принципу единственной ответственности)*. Такая организация кода в приложении — это как переход от хлипкой архитектуры бумаги и скрепок к дереву и гвоздям. Это гарантирует большую надёжность.

В других случаях функция может специально вернуть `Nothing` для того, чтобы сообщить о некорректном результате, несмотря на то, что технически его возможно вычислить.

```js
// withdraw :: Number -> Account -> Maybe(Account)
const withdraw = curry((amount, { balance }) =>
  Maybe.of(balance >= amount ? { balance: balance - amount } : null));

// Это "гипотетическая" функция... Мы не будем определять её реализацию — просто представим, что она есть.
// updateLedger :: Account -> Account 
const updateLedger = account => account;

// remainingBalance :: Account -> String
const remainingBalance = ({ balance }) => `Your balance is $${balance}`;

// finishTransaction :: Account -> String
const finishTransaction = compose(remainingBalance, updateLedger);


// getTwenty :: Account -> Maybe(String)
const getTwenty = compose(map(finishTransaction), withdraw(20));

getTwenty({ balance: 200.00 }); 
// Just('Your balance is $180')

getTwenty({ balance: 10.00 });
// Nothing
```

`withdraw` откажется проводить списание и вернёт `Nothing`, если у нас окажется недостаточно денег. Эта функция тоже явно сообщает о том, что не каждое её применение может произвести нужный нам результат, и не оставляет нам другого выбора, кроме как `map`ить то, что она вернёт. Но, в отличие от предыдущего примера, мы возвращаем `Nothing` преднамеренно *(используя `null` только для того, чтобы произвести такое значение)*, что останавливает наше приложение от совершения последующих действий. Важно отметить: если `withdraw` не приведёт к успешному результату, то `map` не станет выполнять ни одного последующего действия, а именно — `finishTransaction`. Это именно то поведение, которое нам нужно, поскольку мы предпочли бы не обновлять баланс счёта и не показывать новый остаток, если не получилось списать нужный объём средств.

## Извлечение значения

Наше представление осталось бы неполным, если бы мы упустили тот факт, что нельзя просто так взять и «вернуть» что-либо из программы – нужно использовать некоторую функцию, которая передаст миру результат работы программы. Функцию, которая либо куда-то отправит получившееся значение в формате JSON, либо отобразит его на экране, либо сделает изменение в файловой системе или ещё что-нибудь «эффектное».

Можно сформулировать это как дзен-буддистский коан: «Если программа не имеет видимого эффекта, выполняется ли она вообще?». И, даже если так – выходит, она работает корректно только ради своего собственного удовлетворения? В этом случае есть подозрение, что на самом деле она отрабатывает пару тактов и снова отправляется спать...

Работа нашего приложения состоит в том, чтобы принимать, преобразовывать и перекладывать данные до тех пор, пока не наступит момент, когда нужно предъявить результат. И все преобразования можно проделывать при помощи `map` без необходимости извлекать значения из контейнера. Более того, пытаться грязными хаками извлечь значение из `Maybe` - распространённая ошибка *(например, пытаясь добраться до соответствующего поля в объекте)*, Делать так – значит полагать, что возможное значение внутри внезапно материализовалось, и «всё было прощено». Это ошибочно, потому что значения может не оказаться вовсе. С того момента, как значение оказалось внутри `Maybe`, для всего последующего кода, как для кота Шрёдингера, существует 2 реальности одновременно. Если мы поддерживаем этот контекст до самого конца, то можем описывать нашу программу линейно, несмотря на логическое ветвление. 

Тем не менее, мы сможем совершенно корректно извлекать значение, если в явном виде опишем продолжение программы для каждого из возможных значений в типе `Maybe a`: для `Just a` и `Nothing` (здесь – при помощи вспомогательной функции `maybe`).

 *В других функциональных языках такая операция над типом-суммой называется «сопоставление с образцом» (pattern matching). Наиболее уместно применять его тогда, когда операций, определённых над `Maybe`, окажется недостаточно для продолжения композиции. С этого момента либо начинается ветвление, и разные эффекты выполняются для разных случаев, либо все частные случаи должны быть сведены к значениям одного типа (как в примере ниже), тогда можно продолжать композицию – прим. пер.*

```js
// maybe :: b -> (a -> b) -> Maybe a -> b
const maybe = curry((v, f, m) => {
  if (m.isNothing) {
    return v;
  }

  return f(m.$value);
});

// getTwenty :: Account -> String
const getTwenty = compose(maybe('You\'re broke!', finishTransaction), withdraw(20));

getTwenty({ balance: 200.00 }); 
// 'Your balance is $180.00'

getTwenty({ balance: 10.00 }); 
// 'You\'re broke!'
```

Теперь мы либо вернём статическое значение (того же типа, что возвращает `finishTransaction`), либо успешно получим результат выполнения транзакции за пределами `Maybe`. Очевидно, что аналогом функции `maybe` в императивном стиле будет `if/else`, в то время как императивным аналогом функции `map` будет `if (x !== null) { return f(x) }`.

Работа с `Maybe` поначалу может ощущаться дискомфортной. Пользователи Swift и Scala поймут, о чём я – в этих языках `Maybe` повсеместно используется в стандартной библиотеке и носит названия `Optional` и `Option`, и компилятор заставляет выполнять проверку *всегда* (зачастую при том, что мы абсолютно уверены в наличии значения). Неудивительно, что большая часть людей находит это трудоёмким. Но постепенно это станет естественным, и тогда вы начнёте высоко ценить эту строгость. В конце концов, в большинстве случаев она будет нас спасать.

Не стремиться исключить ошибки – значит заниматься разработкой ненадёжного ПО. Это как старательно разукрашивать яйца, а затем швырнуть их на дорогу; это как строить дом престарелых из материалов, которыми не воспользовались бы даже три поросёнка. Надёжность всегда пойдёт на пользу нашим функциям, и `Maybe` даёт нам именно её.

Было бы упущением с моей стороны не упомянуть, что «настоящая» имплементация подразумевает, что `Maybe` представлен двумя частными случаями: один для содержания какого-то значения, а другой - для отсутствия _(так, существует 2 способа произвести значение Maybe, т.е. у него есть 2 конструктора значений)_. Такая реализация позволяет реализовать функцию `map` параметрически полиморфной (как того требует функтор), и значения `null` и `undefined` могут быть возвращены наравне со всеми остальными. Вам чаще будет встречаться `Maybe`, который представлен значениями вроде `Some(x) / None` или `Just(x) / Nothing`, нежели такой `Maybe`, который проверяет на `null` помещаемое в него значение.

## Чистая обработка ошибок

<img src="images/fists.jpg" alt="pick a hand... need a reference" />

Возможно, это вас шокирует, но конструкция `throw/catch` не является чистой. Когда возбуждается исключение, вызванная функция больше не сможет вернуть никакого значения _(а любая чистая функция должна по определению)_. Вместо этого она поднимает тревогу и защищается от нас. С новым помощником `Either` наши функции смогут делать нечто лучшее, чем объявлять войну некорректным аргументам – вместо этого они смогут отвечать вежливым отказом. Давайте рассмотрим пример:

> Полная реализация `Either` приведена в [Приложении B](./appendix_b-ru.md#Either)

```js
class Either {
  static of(x) {
    return new Right(x);
  }

  constructor(x) {
    this.$value = x;
  }
}

class Left extends Either {
  map(f) {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }
}

class Right extends Either {
  map(f) {
    return Either.of(f(this.$value));
  }

  inspect() {
    return `Right(${inspect(this.$value)})`;
  }
}

const left = x => new Left(x);
```

`Left` и `Right` – это частные случаи некоторого абстрактного типа `Either` _(то, что данная реализация выглядит как наследование классов, не имеет значения, как не имеет значения и то, что мы опустили церемонию обращения к конструктору суперкласса – на идею наследования наши рассуждения опираться не будут)_. Давайте рассмотрим, как работают `Left` и `Right`:

```js
Either.of('rain').map(str => `b${str}`); 
// Right('brain')

left('rain').map(str => `It's gonna ${str}, better bring your umbrella!`); 
// Left('rain')

Either.of({ host: 'localhost', port: 80 }).map(prop('host'));
// Right('localhost')

left('rolls eyes...').map(prop('host'));
// Left('rolls eyes...')
```

`Left` ведёт себя как подросток, он игнорирует наши попытки заставить его поработать с `map`. А `Right` будет работать в точности, как `Container` (a.k.a `Identity`). Сила состоит в возможности поместить сообщение об ошибке внутрь `Left`.

Предположим, у нас есть функция, для которой возможно неуспешное вычисление. Например, функция, вычисляющая возраст человека по дате рождения. Мы могли бы использовать `Nothing` для того, чтобы сообщить о неуспешном исходе и тем самым подтолкнуть к обработке этого случая в нашей программе, однако это окажется неинформативным, если для неудачи существует несколько возможных причин. Не исключено, что нам может потребоваться знать точную причину. Давайте реализуем такую возможность при помощи `Either`.

```js
const moment = require('moment');

// getAge :: Date -> User -> Either(String, Number)
const getAge = curry((now, user) => {
  const birthDate = moment(user.birthDate, 'YYYY-MM-DD');

  return birthDate.isValid()
    ? Either.of(now.diff(birthDate, 'years'))
    : left('Birth date could not be parsed');
});

getAge(moment(), { birthDate: '2005-12-12' });
// Right(9)

getAge(moment(), { birthDate: 'July 4, 2001' });
// Left('Birth date could not be parsed')
```

Как и в случае с `Nothing`, мы останавливаем дальнейшую работу, когда возвращаем `Left`. Разница в том, что сейчас у нас есть подсказка о причине остановки вычисления. Обратите внимание на тип возвращаемого значения – `Either(String, Number)` – он содержит информацию о типах для частных случаев, которыми он может быть представлен: `String` для `Left` и `Number` для `Right`. Такая сигнатура довольно неформальна, поскольку мы условились не рассуждать в терминах наследования, но мы многое можем из неё понять. Она говорит нам о том, что в результате мы получим либо строку с сообщением об ошибке, либо число, означающее возраст.

```js
// fortune :: Number -> String
const fortune = compose(append('If you survive, you will be '), toString, add(1));

// zoltar :: User -> Either(String, _)
const zoltar = compose(map(console.log), map(fortune), getAge(moment()));

zoltar({ birthDate: '2005-12-12' });
// 'If you survive, you will be 10'
// Right(undefined)

zoltar({ birthDate: 'balloons!' });
// Left('Birth date could not be parsed')
```

В случае, когда поле `birthDate` содержит валидную дату, программа выведет нам своё «предсказание» о возрасте через год. В противном случае нам достанется контейнер `Left`, в котором в неизменном виде будет содержаться сообщение об ошибке парсинга. Это подобно «бросанию» ошибок, только осуществляется спокойно, без истерик.

В этом примере мы разделяем поток управления в зависимости от валидности даты, но такой код читается легко, потому что написан последовательно, как будто ветвлений нет, и нам не приходится карабкаться взглядом по фигурным скобкам условных выражений. Обычно мы бы вынесли `console.log` за пределы функции `zoltar` и выводили бы результат в каком-то другом месте, но сейчас это помогает нам наблюдать отличие варианта `Right`. Мы используем `_` в сигнатуре типа Right для того, чтобы обозначить, что значение после `console.log` должно быть проигнорировано (В некоторых браузерах может потребоваться установить контекст для метода `log`, чтобы использовать его как функцию первого класса: `console.log.bind(console)`).

Пользуясь случаем, я хотел бы обратить ваше внимание на то, что `fortune`, несмотря на использование `Either`, совершенно ничего не знает о функторах и `map`. То же можно отметить и о `finishTransaction` из предыдущего примера. Можно сказать, что `map` делает из любой функции такую, которая может работать с функторами. Это называется **поднятием** *(lifting)* _(это утверждение несколько неточное, но в последующих главах тема будет раскрыта полнее – прим. пер.)_. Как правило, лучше определять функции для обыкновенных типов данных, а затем `map` позаботится о том, чтобы они работали с нужным контейнером. Тогда функции останутся простыми, их будет легче повторно использовать и подстраивать под ситуацию.

`Either` одинаково хорошо подходит для обработки ошибок разного рода – начиная от валидаций и заканчивая критическими ошибками, после наступления которых приложение должно прекратить свою работу (например, из-за отсутствия нужных файлов или неисправностей с сетевым соединением). В качестве упражнения вы можете переделать примеры с `Maybe` на `Either`, чтобы предоставлять больше информации.

Я хотел бы исправить то, что оказал `Either` медвежью услугу, когда представил его как контейнер для сообщений об ошибках. На самом деле, `Either` позволяет выражать дизъюнкцию на типах (иначе говоря – логическое «или», `||`). Он также выражает идею копродукта *(Coproduct)* из теории категорий. Это канонический тип-сумма *(sum-type, disjoint union of sets)*: он носит такое название потому, что его мощность равна сумме мощностей типов, которые представляют собой его частные случаи _(то есть, количество возможных значений типа `Either A B` – это количество возможных значений, произведённых конструкторами `Left A` и `Right B`, это количество возможных значений типа `A` + количество возможных значений типа `B` – прим. пер.)_. Подробности не будут рассматриваться в данной книге, но об этом определённо стоит почитать и ознакомиться со свойствами таких типов – вот [великолепная статья](https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types). Запомнить стоит то, что `Either` может быть использован множеством способов, но как функтор он используется для обработки ошибок.

Как и в случае с `Maybe`, у нас есть функция `either`, которая ведёт себя схожим образом, но принимает 2 функции вместо одной. Тип возвращаемых значений у этих функций должен совпадать:

```js
// either :: (a -> c) -> (b -> c) -> Either a b -> c
const either = curry((f, g, e) => {
  let result;

  switch (e.constructor) {
    case Left:
      result = f(e.$value);
      break;

    case Right:
      result = g(e.$value);
      break;

    // No Default
  }

  return result;
});

// zoltar :: User -> _
const zoltar = compose(console.log, either(id, fortune), getAge(moment()));

zoltar({ birthDate: '2005-12-12' });
// 'If you survive, you will be 10'
// undefined

zoltar({ birthDate: 'balloons!' });
// 'Birth date could not be parsed'
// undefined
```

Наконец-то нам пригодилась эта загадочная функция `id`. Она без изменений отдаст значение, которое может содержаться в `Left`, и оно будет передано в `console.log`. Мы сделали наше  приложение для гадания более надёжным, начиная с `getAge`. Далее мы либо раскрываем пользователю страшную правду об ошибке, либо продолжаем ожидаемое от нас «гадание». Теперь мы готовы перейти к освоению совершенно другой разновидности функторов.

## У старого Макдональда были эффекты...

<img src="images/dominoes.jpg" alt="dominoes.. need a reference" />

В главе о чистых функциях есть очень своеобразный пример чистой функции. Эта функция содержала побочный эффект но мы сделали её чистой, когда вынесли этот побочный эффекта в другую функцию. Вот еще один такой же пример:

```js
// getFromStorage :: String -> (_ -> String)
const getFromStorage = key => () => localStorage[key];
```

Если бы мы не обернули это в еще одну функцию `getFromStorage` резултат варировался бы в завимости от вшеншних условий. Добавляя еще одну функцию обертку, мы всегда будем иметь один и тот же вывод с одними и теми же входными данными: у нас будет функция, которая при вызове извлекает определенный элемент из localStorage.И таким образом мы очистили нашу совесть, и все прощено.

Однако следует признать, что такая функция нам не очень полезна. Так же как коллекционная фигура хранящияся в её оригинальной упаковке, мы не можем играть с ней. Если бы существовал способ проникнуть внутрь контейнера и получить его содержимое... Встречайте `IO`.

```js
class IO {
  static of(x) {
    return new IO(() => x);
  }

  constructor(fn) {
    this.$value = fn;
  }

  map(fn) {
    return new IO(compose(fn, this.$value));
  }

  inspect() {
    return `IO(${inspect(this.$value)})`;
  }
}
```

`IO` отличается от предудыщих функторов тем что `$value` всегда функция.Но мы не думаем об `$value`
как о функции - детали реализации лучше всего оставить без внимания. То, что происходит здесь, является
именно тем, что мы видели в примере с `getFromStorage`:
 `IO` откладывает выполнения нечистого действия, оборачивая его в функцию обертку.
  Поэтому мы воспринимаем `IO` как сущность содержащую возвращаемое значение дейсвтия которое мы обернули в функцию обертку а не как саму функцию обертку.
Это очевидно в функции `of`: У нас есть `IO(x)`, а `IO(() => x)` просто необходима для задержки выполнения.
Обратите внимание что для упрощения мы покажем гипотетическое значение,
содержавшееся в `IO` как результат; Однако, на практике Вы не можете сказать какое там значение,
пока вы на самом деле не запустите эффекты!

Давайте посмотрим на это в действии:

```js
// ioWindow :: IO Window
const ioWindow = new IO(() => window);

ioWindow.map(win => win.innerWidth);
// IO(1430)

ioWindow
  .map(prop('location'))
  .map(prop('href'))
  .map(split('/'));
// IO(['http:', '', 'localhost:8000', 'blog', 'posts'])


// $ :: String -> IO [DOM]
const $ = selector => new IO(() => document.querySelectorAll(selector));

$('#myDiv').map(head).map(div => div.innerHTML);
// IO('I am some inner html')
```

Здесь `ioWindow` это фактический `IO` который мы можем сразу обрабатывать c помощью `map` , в то время как `$`  это функция которая возвращающает `IO` после того как она была вызвана. Я написал *концептуальные* возвращаемые значения, чтобы лучше показать `IO`, тем не менее, в действительности, оно всегда будет `{ $value: [Function] }`. Когда мы c помощью `map` обрабатываем наш `IO`, мы отправляем в конец композиции тут функцию, которая, в свою очередь, станет новым `$value`. Наши замапленные функции не запускаются, Они  просто занимает свое место в конце цепочки вычислений, которую мы строим, функция за функцией, подобно тому как мы осторожно расставляем домино стараясь ничего не задеть. Результат напоминает паттерн проектирования "очередь" или "команда" из книги «Банды четырех»

Потратьте минутку, чтобы направить свою "фанктор" интуицию. Если мы не будем смотреть на детали реализации, мы должны чувствовать себя как дома, обрабатывая любой тип контейнера, независимо от его причуд или особенностей. Эта псевдо-сверхъестественная сила объясняется законами функтора, которые мы рассмотрим в конце этой главы. В любом случае мы можем, наконец, работать с нечистыми значениями, не жертвуя нашей драгоценной чистотой.

Теперь мы держим зверя в клетке, но в некоторых случаях нам будет необходимо выпустить его в какой-то момент. Обработка нашего `IO` создало мощное нечистое вычисление и вызов его может нарушить установленный порядок.Итак, где и когда мы можем выпускать нашего зверя? Возможно ли запустить наш `IO` и при этом не спровоцировавть конец света? Ответ: Да, Если мы переложим отвественность на тот код который вызывает вычисления. Наш чистый код, несмотря на гнусные заговоры и интриги, сохраняет свою невиновность, наш козел отпущение это тот кто начинает выполнение он получает бремя в виде ответственности за фактическое выполнение эффектов. Давайте рассмотрим конкретный пример.

```js
// url :: IO String
const url = new IO(() => window.location.href);

// toPairs :: String -> [[String]]
const toPairs = compose(map(split('=')), split('&'));

// params :: String -> [[String]]
const params = compose(toPairs, last, split('?'));

// findParam :: String -> IO Maybe [[String]]
const findParam = key => map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);

// -- Impure calling code ----------------------------------------------

// run it by calling $value()!
findParam('searchTerm').$value();
// Just([['searchTerm', 'wafflehouse']])
```

Наша библиотека освобождается от ответственности и сохраняет свою чистоту, инкапсулируя  `url`  в IO и перекладывая ответсвенность на вызывающую функцию. Вы, возможно, также заметили, что мы сложили(собрали в кучу) наши контейнеры. Вполне разумно иметь `IO(Maybe([x]))` который имеет три функтора в глубину(`Array` - это тип контейнера,к которому `map` применяется чаще всего) и черезвычайно наглядный.

Есть кое-что что меня беспокоит в течение длительного времени, и мы должны исправить это немедленно: `$value` в `IO` это не самом деле не значение которое он содержит и не его частное свойство. Это чека на гранате,и вытощит эту чеку тот кто вызовет это свойство. Давайте переменуем это свойство в  `unsafePerformIO` что бы напомнить нашим пользователям о его непостоянстве.

```js
class IO {
  constructor(io) {
    this.unsafePerformIO = io;
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}
```

Так намного лучше. Теперь наш код вызова преобразуется в `findParam('searchTerm').unsafePerformIO()`, что ясно как белый день для пользователей (и читателей) этого приложения.

`IO` Станет нашим верным компаньоном, помогая нам одомашнить эти дикие нечистые операции. В следующем разделе мы вооружаемся другим типом, он схож по духу, но они различаются в зависимости от типа использования.

## Асинхронные задачи

Обратные вызовы - это винтовая лестница в ад. Обратные вызовы это управляющии потоки, разработанные M.C. Escher. Они контролируют поток выполнения приложения. С каждым обратным вызовом, вложенным между фигурных или круглых скобок, Наши функции обратного вызова начинают чувствовать себя как Limbo в подземелье (как глубоко мы можем пойти?). У меня начинается клаустрофобия просто даже думая о них. Но не стоит сильно волноваться, у нас есть гораздо лучший способ для работа с асинхронным кодом и название его начинается на "F"

Внутренний механизм этого подхода немного сложно разместить на этой странице, поэтому мы будем использовать Data.Task(ранее Data.Future) знакомтесь Quildreen Motta и его фантастическая библиотеку [Folktale](http://folktale.origamitower.com/). Вот некоторые примеры использования:

```js
// -- Node readFile example ------------------------------------------

const fs = require('fs');

// readFile :: String -> Task Error String
const readFile = filename => new Task((reject, result) => {
  fs.readFile(filename, (err, data) => (err ? reject(err) : result(data)));
});

readFile('metamorphosis').map(split('\n')).map(head);
// Task('One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that
// in bed he had been changed into a monstrous verminous bug.')


// -- jQuery getJSON example -----------------------------------------

// getJSON :: String -> {} -> Task Error JSON
const getJSON = curry((url, params) => new Task((reject, result) => {
  $.getJSON(url, params, result).fail(reject);
}));

getJSON('/video', { id: 10 }).map(prop('title'));
// Task('Family Matters ep 15')


// -- Default Minimal Context ----------------------------------------

// We can put normal, non futuristic values inside as well
Task.of(3).map(three => three + 1);
// Task(4)
```

Функции которые я называю `reject` и `result` это наши функции обратного вызова `error` и `success` соотвественно. Как вы можете видет, Мы просто обрабатываем `Task` c помощью `map` работая над будущим значением, как если бы оно  было прямо здесь под рукой. К настоящему времени, `map` уже должен был порядком приесться.

Если вы знакомы с промисами, ты вы скорее всего уже поняли что наша функция `map` это `then` а вот наш `Task` по сути играет роль промиса. Не волнуйтесь если вы не знакомы с промисами, мы в любом случае не будем их использовать, поскольку они не чистые, но аналогия по-прежнему верна.

Подобно `IO`,  `Task` будет терпеливо ждать, пока мы дадим ему зеленый свет перед выполнением. По сути, из-за того что он ждет нашей команды, мы можем сказать что `IO` фактически включается в `Task` для всей асинхронной работы;  `readFile` и `getJSON` не требуют дополнительного `IO` контейнера для того что бы быть чистыми. Более того, `Task` работает аналогичным образом когда мы обрабатываем его с помощью `map`. Мы помещаем в капусулу времени инструкции на будущее, похожий на список дел - это пример сложной технологической формы прокрастинации

Что бы запустить наш `Task`, мы должны вызвать метод `fork`. Это работает аналогично `unsafePerformIO` кроме того, как следует из названия, этот метод породит дочерений процесс и будет выполнять задачу без прерывания текущего процесса. Это может быть реализовано различными способами например с помощью потоков и т.д, но здесь он работает как обычный асинхронный вызов, и Event-loop просто обрабатывает его. Давайте посмотрим на `fork`:

```js
// -- Pure application -------------------------------------------------
// blogPage :: Posts -> HTML
const blogPage = Handlebars.compile(blogTemplate);

// renderPage :: Posts -> HTML
const renderPage = compose(blogPage, sortBy(prop('date')));

// blog :: Params -> Task Error HTML
const blog = compose(map(renderPage), getJSON('/posts'));


// -- Impure calling code ----------------------------------------------
blog({}).fork(
  error => $('#error').html(error.message),
  page => $('#main').html(page),
);

$('#spinner').show();
```

После вызова `fork`, `Task` спешит найти записи и отрендерить страницу. В это время мы показываем анимацию ожидания поскольку `fork` не ждет ответа(не блокируется). В результате, мы покажем или ошибку или выведем страницу с данными на экран в зависимости от того что вернет `getJSON`.

Потратьте минутку, чтобы посмотреть насколько линейный поток управления здесь. Мы можем просто читать снизу вверх, справа налево, несмотря на то, что во время выполнения программа будет прыгать по коду. Это делает чтение и понимания того что происходит внутри приложения гораздо более простым, чем переход между различными блоками обработки обратных вызовов и блоками обработки ошибок.

Боже мой, посмотрите на этот `Task` он так же включает в себя `Either`! И Он должен был это сделать потому, что наш предыдущий поток управления не применяется в асинхронном мире, где мы можем иметь дело с потенциальными ошибками. Это все просто замечательно, так как это обеспечивает нам достаточную и чистую обработку ошибок прямо из коробки.

Даже имея `Task`, наши `IO` и `Either` не останутся без работы. Позвольте мне покзать вам простой пример, который опирается на более сложную и гипотетическую сторону, но этот пример полезен в качестве иллюстрации.

```js
// Postgres.connect :: Url -> IO DbConnection
// runQuery :: DbConnection -> ResultSet
// readFile :: String -> Task Error String

// -- Pure application -------------------------------------------------

// dbUrl :: Config -> Either Error Url
const dbUrl = ({ uname, pass, host, db }) => {
  if (uname && pass && host && db) {
    return Either.of(`db:pg://${uname}:${pass}@${host}5432/${db}`);
  }

  return left(Error('Invalid config!'));
};

// connectDb :: Config -> Either Error (IO DbConnection)
const connectDb = compose(map(Postgres.connect), dbUrl);

// getConfig :: Filename -> Task Error (Either Error (IO DbConnection))
const getConfig = compose(map(compose(connectDb, JSON.parse)), readFile);


// -- Impure calling code ----------------------------------------------

getConfig('db.json').fork(
  logErr('couldn\'t read file'),
  either(console.log, map(runQuery)),
);
```

В этом примере, мы все так же используем `Either` и `IO` в ветке которая отвечает за успешное выполнение `readFile`. `Task` обрабатывает грязную операцию чтения файла асинхронно.  но нам все же приходится иметь дело с проверкой конфигурации с `Either` и обсуждать с `IO` соединение c db. Как вы можете видеть, мы все еще работаем со всеми синхронными вещами.

Я мог бы продолжать, но это всё что есть по этому поводу. Просто как `map`.

На практике, у вас будут несколько асинхронных тасков в одном рабочем процесе, но мы еще не полностью изучили api контейнера для решения этой ситуации. Не волнуйтесь, мы посмотрим на монады и т.д, но сначала мы должны рассмотреть математику, которая сделает все это возможным.


## Немного теории

Как мы упоминали ранее, понятие функторы берут свое начало из теории категорий и удовлятворяют нескольким законам. Давайте сначала рассмотрим эти полезные свойства.

```js
// identity
map(id) === id;

// composition
compose(map(f), map(g)) === map(compose(f, g));
```

Закон об *идентичности* прост, но важен. Эти законы могут быть применены в нашем коде, поэтому давайте протестируем их на наших функторах, чтобы подтвердить их легитимность.

```js
const idLaw1 = map(id);
const idLaw2 = id;

idLaw1(Container.of(2)); // Container(2)
idLaw2(Container.of(2)); // Container(2)
```

Как видете они равны. Дальше давайте посмотрим на композицию  

```js
const compLaw1 = compose(map(append(' world')), map(append(' cruel')));
const compLaw2 = map(compose(append(' world'), append(' cruel')));

compLaw1(Container.of('Goodbye')); // Container(' world cruelGoodbye')
compLaw2(Container.of('Goodbye')); // Container(' world cruelGoodbye')
```

В теории категорий функторы принимают объекты и морфизмы категории и преобразовывают их в другую категорию. По определению эта новая категория должна иметь идентичность и способность составлять морфизмы, но нам не нужно это проверять, потому что вышеупомянутые законы гарантируют, что они сохранены.

Возможно, наше определение категории все еще немного нечеткое. Вы можете представить категорию как своего рода сеть объектов, взаимосвязанных морфизмами. Таким образом, функтор будет преобразовывать одну категорию в другую при этом сохраняя структуру этой сети. Если объект `a` находится в нашей исходной категории `C`, то когда мы преобразовываем её в категорию `D` с помощью функтора `F` мы ссылаемся на этот объект как `F a`. (Если собрать все это вместе то что все это будет значить?) Наверно, гораздо проще просто посмотреть на рисунок :

<img src="images/catmap.png" alt="Categories mapped" />

К примеру, `Maybe` преобразовывает нашу категорию типов и функий в категорию где каждый объект может не существовать и каждый морфизм имеет проверку на `null`.В коде мы достигаем этого путем, обарачивания каждой функции в `map` и каждого типа в наш функтор. Это гарантирует нам, что каждый общий тип и функция могут продолжать использовать композицию в этой новой среде. Технически, каждый функтор в нашем коде преобразоывается в подкатегорию типов и функций, что делает все наши функторы - эндофункторами. Но мы специально в этой книги считаем, что это другая категория.

Мы также можем визуализировать отображение морфизма и его соответствующих объектов с помощью диаграммы:

<img src="images/functormap.png" alt="functor diagram" />

В дополнение к визуализации преобразованого морфизма из одной категорий в другую с помощью функтора `F`, мы видим также что диаграмма соответствует коммутативному закону, то есть, порядок в котором идут стрелки не имеет значения, мы получим постоянно один и тот же результат.Различные пути означают разные типы поведения, но в конечном счете ,все они приведут к одному и тому же типу. Этот формализм дает нам возможность принципиально подумать о коде - мы можем смело применять формулы без необходимости анализировать и рассматривать каждый отдельный сценарий. Давайте рассмотрим конкретный пример.

```js
// topRoute :: String -> Maybe String
const topRoute = compose(Maybe.of, reverse);

// bottomRoute :: String -> Maybe String
const bottomRoute = compose(map(reverse), Maybe.of);

topRoute('hi'); // Just('ih')
bottomRoute('hi'); // Just('ih')
```

Или визуально:

<img src="images/functormapmaybe.png" alt="functor diagram 2" />

В соответствии с особенностями функторов мы можем сразу понять и отрефакторить код.

Функторы могут складываться

```js
const nested = Task.of([Either.of('pillows'), left('no sleep for you')]);

map(map(map(toUpperCase)), nested);
// Task([Right('PILLOWS'), Left('no sleep for you')])
```

Что нам дает `nested` здесь - это будущий массив элементов, которые могут быть ошибками. Мы используем `map` каждый раз, чтобы проникнуть в одну из структур, чтобы применить нашу функцию к элементам. Мы не используем никаких callbacks,if/else конструкций или for циклов, только явный контекст.Однако мы должны делать это `map(map(map(f)))`. Вместо этого мы можем просто использовать композицию с функторами. Вы меня правильно поняли:

```js
class Compose {
  constructor(fgx) {
    this.getCompose = fgx;
  }

  static of(fgx) {
    return new Compose(fgx);
  }

  map(fn) {
    return new Compose(map(map(fn), this.getCompose));
  }
}

const tmd = Task.of(Maybe.of('Rock over London'));

const ctmd = Compose.of(tmd);

const ctmd2 = map(append(', rock on, Chicago'), ctmd);
// Compose(Task(Just('Rock over London, rock on, Chicago')))

ctmd2.getCompose;
// Task(Just('Rock over London, rock on, Chicago'))
```

Теперь только один `map`. Композиция на функторах является ассоциативной, помните ранее, мы определили `Container` который на самом деле является не чем иным, как функтором `Identity`. Если у нас есть тождество и ассоциативная композиция, то у нас есть категория.  Объектами данной категории являются другие категории, а морфизмами - функторы, этого достаточно что бы закипел ваш мозг. Мы не будем слишком подробно останавливаться на этом, но приятно оценить последствия применения этой архитектуры и оценить красоту ее простой абстракции.

## Итог

Мы посмотрели на несколько разлиных функторов, но их существует бесконечно много. Некоторые упущения заслуживающие внимания это итерируемые структуры данных такие как деревья, списки,  ассоциативные массивы, пары и тому подобные. Потоки событий и observable'ы тоже являются функторами. Другие функторы могут использоваться для инкапсуляции или просто для что выразить определенный тип. Функторы вокруг нас, и мы будем использовать их в течение всей книги.

Можно ли вызвать функцию с несколькими функторами в аргументах? Как обрабатывать упорядоченную последовательность нечистых или асинхронных операций? У нас еще нет всех инструментов, которые нам нужны для работы в мире где все завернуто в контейнеры. Теперь давайте перейдем к делу и посмотрим, что такое монады.

[Chapter 09: Monadic Onions](ch09-ru.md)

## Упражнения

### Упражнение A

Use `add` and `map` to make a function that increments a value inside a functor.  
  
```js  
// incrF :: Functor f => f Int -> f Int  
const incrF = undefined;  
```  

### Упражнение B

Используя следующий объект пользователя:
  
```js  
const user = { id: 2, name: 'Albert', active: true };  
```  
  
Используйте `safeProp` и `head` для того, что бы найти первую букву имени пользователя.
  
```js  
// initial :: User -> Maybe String  
const initial = undefined;  
```  

### Упражнение C

Используя следующую вспомогательную функцию:

```js
// showWelcome :: User -> String
const showWelcome = compose(append('Welcome '), prop('name'));

// checkActive :: User -> Either String User
const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left('Your account is not active');
};
```

Напишите функцию, которая использует `checkActive` и `showWelcome`, чтобы предоставить доступ или вернуть ошибку.

```js
// eitherWelcome :: User -> Either String String
const eitherWelcome = undefined;
```

### Упражнение D

Теперь рассмотрим следующую функцию:

```js
// validateUser :: (User -> Either String ()) -> User -> Either String User
const validateUser = curry((validate, user) => validate(user).map(_ => user));

// save :: User -> IO User
const save = user => new IO(() => ({ ...user, saved: true }));
```

Напишите функцию `validateName`, которая проверяют длину имени пользователя, и если длина меньше чем 3 символа, то возвращает ошибку. Затем используейте `either`, `showWelcome` и `save`, чтобы написать функцию `register`, чтобы зарегистрировать и поприветствовать пользователя, если он прошел валидацию. 

Помните, что оба аргумента `either` должны возвращать один и тот же тип.

```js
// validateName :: User -> Either String ()
const validateName = undefined;

// register :: User -> IO String
const register = compose(undefined, validateUser(validateName));
```
