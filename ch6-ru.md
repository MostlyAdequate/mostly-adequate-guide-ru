# Глава 6: Пример приложения

## Декларативное программирование

Нам предстоит поменять образ мышления. С этого момента мы прекращаем говорить компьютеру о том, как он должен выполнять свою работу, вместо этого будем составлять описание желаемого результата. Я уверен, что вы найдёте этот подход намного менее наряжным, чем попытки вручную управлять каждой мелочью.

Декларативный подход, в отличие от императивного, подразумевает, что мы будем писать выражения, а не пошаговые инструкции.

Вспомните SQL – там нет «Сначала сделай то, затем сделай это». Есть единое выражение, которое определяет, что именно мы хотели бы получить из базы данных. Не мы решаем, как выполнить работу, а сама база. Когда её версия обновится и, к примеру, детали реализации SQL изменятся, нам не придётся редактировать код запросов. Взаимодействие с базой реализовано так потому, что существует множество способов интерпретировать нашу спецификацию и получить такой же результат.

Некоторым людям, включая меня, будет непросто осмыслить концепцию декларативного кодирования вот так сразу, поэтому давайте рассмотрим несколько примеров, чтобы получить более полное представление.

```js
// императивно
const makes = [];
for (let i = 0; i < cars.length; i += 1) {
  makes.push(cars[i].make);
}

// декларативно
const makes = cars.map(car => car.make);
```

В императивном варианте перед циклом нужно сначала инициализировать массив. Интерпретатор должен выполнить эту инструкцию перед тем как двигаться дальше. Затем интерпретатор обходит непосредственно список автомобилей, вручную увеличивая счетчик, вульгарно демонстрируя нам каждую часть итерации.

Вариант с `map` - это одно выражение, ему не требуется особенного порядка исполнения *(как это нужно для инструкций)*. В том, как именно функция `map` будет проходить по массиву, и как она будет компоновать полученный результат, для неё остается много свободы. Такой вариант определяет *что* сделать, а не *как*, поэтому может гордо называться декларативным.

Помимо ясности и краткости, функция `map` допускает возможность оптимизации без внесения изменений в наш драгоценный прикладной код.

Тем из вас, кто подумает: «Да, но ведь императивный цикл работает намного быстрее», я предлагаю ознакомиться с тем, как JIT оптимизирует ваш код. Вот [потрясающее видео, которое прольёт свет на происходящее](https://www.youtube.com/watch?v=g0ek4vV7nEA)

Рассмотрим ещё один пример.

```js
// императивно
const authenticate = (form) => {
  const user = toUser(form);
  return logIn(user);
};

// декларативно
const authenticate = compose(logIn, toUser);
```

Хотя в императивной версии и нет чего-то явно неправильного, это по-прежнему объединение пошаговых команд. Выражение с `compose` просто утверждает факт: аутентификация — это композиция функций `toUser` и `logIn`. Опять же, это оставляет нам пространство для манёвра в поддержке изменений кода и оставляет результаты работы нашего приложения конкретными.

По причине того, что мы не определяем порядок выполнения, декларативное программирование подходит для параллельных вычислений. Объединив этот подход с чистыми функциями, мы получаем функциональное программирование как хороший вариант для использования в асинхронных вычислениях, нам не нужно делать что-то особенное, чтобы получить параллельные или асинхронно выполняющие код системы.

## Flickr в функциональном стиле

Сейчас мы построим пример приложения декларативным, компонуемым способом. Пока что мы схитрим и будем использовать побочные эффекты, но мы будем использовать их по-минимуму и отделять от чистого кода. Мы собираемся написать виджет для браузера, который парсит изображения из flickr и выводит их на экран. Начнем с каркаса приложения. Это HTML нашего приложения:

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Flickr App</title>
  </head>
  <body>
    <main id="js-main" class="main"></main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script>
    <script src="main.js"></script>
  </body>
</html>
```

А это основа flickr.js:

```js
const CDN = s => `https://cdnjs.cloudflare.com/ajax/libs/${s}`;
const ramda = CDN('ramda/0.21.0/ramda.min');
const jquery = CDN('jquery/3.0.0-rc1/jquery.min');

requirejs.config({ paths: { ramda, jquery } });
requirejs(['jquery', 'ramda'], ($, { compose, curry, map, prop }) => {
  // код приложения
});
```

Мы выбираем [ramda](http://ramdajs.com) вместо lodash или других вспомогательных библиотек. Она содержит `compose`, `curry` и другие методы. Я использую requirejs, который может показаться излишним, но мы будем использовать его и в дальнейшем, а постоянство это ключ к успеху. Также я начал с объявления прекрасной функции `trace` для облегчения отладки.

Следующий пункт в нашем пути - спецификация. Приложение будет иметь 4 действия.

1. Формировать url для конкретного поискового запроса
2. Делать вызов flickr api
3. Преобразовывать полученный json в html с изображениями
4. Выводить их на экран

Выше упомянуты 2 нечистых действия. Вы их видите? Получение данных с помощью api вызова и вывод их на экран. Давайте напишем их первыми, чтобы сразу отделить их.

```js
const Impure = {
  getJSON: curry((callback, url) => $.getJSON(url, callback)),
  setHtml: curry((sel, html) => $(sel).html(html)),
  trace: curry((tag, x) => { console.log(tag, x); return x; }),
};
```

Тут мы просто оборачиваем методы jQuery, чтобы они были каррируемыми и переставляем аргументы в более удобном порядке. Я выделил эти функции в отдельное пространство имён `Impure`, чтобы мы сразу замечали, что это опасные функции. В последующих примерах мы сделаем эти функции чистыми.

Далее мы должны собрать url-адрес, который му будем передавать функции `Impure.getJSON`.

```js
const host = 'api.flickr.com';
const path = '/services/feeds/photos_public.gne';
const query = t => `?tags=${t}&format=json&jsoncallback=?`;
const url = t => `https://${host}${path}${query(t)}`;
```

Существуют различные причудливые и чересчур сложные методы написания функции `url` в стиле отсутствия ссылок используя моноиды[^Мы изучим их позже] или комбинаторы. Наш выбор – читаемая версия, собирающая эту строку в обычном ссылочном стиле.

Давайте напишем функцию `app`, которая делает вызов и выводит данные на экран.

```js
const app = compose(Impure.getJSON(Impure.trace('response')), url);
app('cats');
```

Этот код вызывает функцию `url`, затем передает полученную строку в функцию `getJSON`, которая частично применяется с `trace`. В результате загрузки приложения, в консоли будет выведен ответ на api вызов.

<img src="images/console_ss.png" alt="console response" />

Мы хотим получить изображения из этого json-объекта. Похоже, что их адреса запрятаны в элементах `items`, а конкретно – в каждом свойстве `m` объекта `media`.

Во всяком случае, для получения этих значений мы можем использовать замечательную универсальную функцию чтения из ramda, с именем `_.prop()`. Ниже представлена оригинальная версия метода:

```js
const prop = curry((property, object) => object[property]);
```

Она достаточно скучная. Мы просто воспользуемся `[]`, для получения доступа к свойству какого-либо объекта. Давайте используем её и получим адреса изображений.

```js
const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
```

Как только мы собрали элементы `items`, мы проходимся по ним функцией `map`, чтобы получить адрес каждого изображения. На выходе – замечательный массив адресов. Давайте используем этот массив в приложении, чтобы вывести изображения на экран.

```js
const render = compose(Impure.setHtml('#js-main'), mediaUrls);
const app = compose(Impure.getJSON(render), url);
```

Мы всего-навсего написали очередную композицию функций, которая вызовет `srcs` и заполнит `<body>` нашего html. Заменив `trace` на `renderImages`, мы можем отобразить что-то помимо чистого json — сейчас это просто ссылки на изображения.

Последним шагом необходимо преобразовать эти ссылки в настоящие картинки. Если бы приложение было большим, мы бы использовали шаблонизатор и библиотеку для работы с DOM, например, Handlebars или React. В нашем же приложении, нам нужен только тег img, поэтому давайте обойдемся jQuery.

```js
const img = src => $('<img />', { src });
```

jQuery-метод `html()` принимает массив тегов. Нам нужно только вставить адреса изображений в теги и передать их дальше в функцию `setHtml`.

```js
const images = compose(map(img), mediaUrls);
const render = compose(Impure.setHtml('#js-main'), images);
const app = compose(Impure.getJSON(render), url);
```

Вот и всё!

<img src="images/cats_ss.png" alt="cats grid" />

Ниже представлен полный скрипт:
[include](./exercises/ch06/main.js)

Полюбуйтесь на получившийся код. Чудесная декларативная конструкция, описывающая то, что мы хотим получить, а не как. Сейчас, мы можем рассматривать каждую строку как уравнение, свойства которого строго соблюдаются. Теперь мы можем пользоваться этими свойствами для размышлений о нашем приложении и рефакторинга.

## Принципиальный рефакторинг

Наш код можно легко улучшить. Сейчас мы проходимся функцией map по массиву чтобы получить адреса изображения, а затем уже по массиву адресов, чтобы сформировать теги . В целях оптимизации можно воспользоваться законом композиции:

```js
// Закон композиции отображений
compose(map(f), map(g)) === map(compose(f, g));
```

Мы можем использовать это свойство для оптимизации кода. Давайте начнём принципиальный рефакторинг.

```js
// Текущий код
const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
const images = compose(map(img), mediaUrls);

```

Давайте объединим методы, использующие map. Мы можем поочерёдно выполнять `srcs` и `images`, благодаря эквивалентности и отсутствия побочных эффектов в этих функциях.

```js
const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(img), map(mediaUrl), prop('items'));
```

Теперь, когда мы выстроили отображения в ряд, можно применить закон композиции.

```js
/*
compose(map(f), map(g)) === map(compose(f, g));
compose(map(img), map(mediaUrl)) === map(compose(img, mediaUrl));
*/

const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(compose(img, mediaUrl)), prop('items'));
```

Теперь интерпретатор будет выполнять только один цикл по преобразованию элементов json в изображения, готовые к выводу на экран. Напоследок, сделаем код более читаемым, вынеся одну функцию.

```js
const mediaUrl = compose(prop('m'), prop('media'));
const mediaToImg = compose(img, mediaUrl);
const images = compose(map(mediaToImg), prop('items'));
```

## Итог

Использовав наши новые знания, мы построили маленькое, но практичное приложение. Основываясь на математических законах, мы отрефакторили код. Но что насчёт обработки ошибок, и ветвления кода? Как же добиться чистоты от всего приложения сразу, а не просто каждый раз выносить функции с побочными эффектами в отдельное пространство имён? Как сделать наш код более выразительным и надёжным? Ответы на эти вопросы мы рассмотрим во второй части книги.

[Глава 7: Хиндли-Милнер и Я](ch7-ru.md)
