# Глава 6: Пример приложения

## Декларативное программирование

Мы приближаемся к изменению образа нашего мышления. С этого момента мы прекращаем говорить компьютеру как делать его работу, вместо того, чтобы указывать ему как вернуть результат. Я уверен, что это будет вызывать у вас меньше стресса, нежели попытки управлять всеми мелочами постоянно.

Декларативный подход, то есть противоположный императивному означает, что мы будем писать выражения, вместо пошаговых инструкций.

Вспомните SQL. Там нет «Сначала сделай то, затем сделай это». Есть выражение, которое определяет, что бы мы хотели сделать с базой данных. Мы не решаем как сделать работу, выражение делает это. Если база данных обновится и движок SQL изменится, то нам не придётся редактировать запросы. Всё происходит так, потому что существует много путей интерпретировать наши условия и получить такой же результат.

Многим, включая меня, может показаться сложным осмыслить концепцию декларативного программирования вот так сразу. Поэтому, давайте обратимся к примерам, чтобы получить более точное представление.

```js
// императивная парадигма
var makes = [];
for (i = 0; i < cars.length; i++) {
  makes.push(cars[i].make);
}

// декларативная парадигма
var makes = cars.map(function(car){ return car.make; });
```

Императивный цикл сначала инициализирует массив. Интерпретатор должен выполнить это выражение перед тем как двигаться дальше. Затем он непосредственно проходит по списку автомобилей, вручную увеличивая счетчик, открыто показывая нам каждую часть итерации.

Вариант с методом `map` – это одно выражение. Оно не требует особого порядка выполнения. В этом столько свободы – вы определяете как проходить по списку и как можно сформировать массив. Выражение определяет *что*, а не *как*. Таким образом, оно использует блестящий декларативный подход.

К тому же, декларативный вариант более краток и ясен. Вы можете оптимизировать функцию `map` по вашему желанию, при этом вам не потребуется менять код самого приложения

Для тех, кто думает: «Да, но ведь это гораздо быстрее – написать императивный цикл», я предлагаю ознакомиться с тем, как JIT оптимизирует ваш код. Вот [ужасное видео, которое может пролить свет на вас](https://www.youtube.com/watch?v=65-RbBwZQdU)

Давайте рассмотрим другой пример.

```js
// императивная парадигма
var authenticate = function(form) {
  var user = toUser(form);
  return logIn(user);
};

// декларативная парадигма
var authenticate = compose(logIn, toUser);
```

Хотя в императивной версии и нет чего-то явно неправильного, это по-прежнему объединение пошаговых команд. Выражение с `compose` просто утверждает факт: аутентификация — это композиция функций `toUser` и `logIn`. Опять же, это оставляет нам пространство для манёвра в поддержке изменений кода и оставляет результаты работы нашего приложения конкретными.

По причине того, что мы не определяем порядок выполнения, декларативное программирование подходит для параллельных вычислений. Объединив этот подход с чистыми функциями, мы получаем функциональное программирование как хороший вариант для использования в асинхронных вычислениях, нам не нужно делать что-то особенное, чтобы получить параллельные или асинхронно выполняющие код системы.

## Flickr в функциональном стиле

Сейчас мы построим пример приложения декларативным, компонуемым способом. Пока что мы схитрим и будем использовать побочные эффекты, но мы будем использовать их по-минимуму и отделять от чистого кода. Мы собираемся написать виджет для браузера, который парсит изображения из flickr и выводит их на экран. Начнем с каркаса приложения. Это HTML нашего приложения:

```html
<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.11/require.min.js"></script>
    <script src="flickr.js"></script>
  </head>
  <body></body>
</html>
```

А это основа flickr.js:

```js
requirejs.config({
  paths: {
    ramda: 'https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min',
    jquery: 'https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min'
  }
});

require([
    'ramda',
    'jquery'
  ],
  function (_, $) {
    var trace = _.curry(function(tag, x) {
      console.log(tag, x);
      return x;
    });
    // код приложения
  });
```

Мы выбираем [ramda](http://ramdajs.com) вместо lodash или других вспомогательных библиотек. Она содержит `compose`, `curry` и другие методы. Я использую requirejs, который может показаться излишним, но мы будем использовать его и в дальнейшем, а постоянство это ключ к успеху. Также я начал с объявления прекрасной функции `trace` для облегчения отладки.

Следующий пункт в нашем пути - спецификация. Приложение будет иметь 4 действия.

1. Формировать url для конкретного поискового запроса
2. Делать вызов flickr api
3. Преобразовывать полученный json в html с изображениями
4. Выводить их на экран

Выше упомянуты 2 нечистых действия. Вы их видите? Получение данных с помощью api вызова и вывод их на экран. Давайте напишем их первыми, чтобы сразу отделить их.

```js
var Impure = {
  getJSON: _.curry(function(callback, url) {
    $.getJSON(url, callback);
  }),

  setHtml: _.curry(function(sel, html) {
    $(sel).html(html);
  })
};
```

Тут мы просто оборачиваем методы jQuery, чтобы они были каррируемыми и переставляем аргументы в более удобном порядке. Я выделил эти функции в отдельное пространство имён `Impure`, чтобы мы сразу замечали, что это опасные функции. В последующих примерах мы сделаем эти функции чистыми.

Далее мы должны собрать url-адрес, который му будем передавать функции `Impure.getJSON`.

```js
var url = function (term) {
  return 'https://api.flickr.com/services/feeds/photos_public.gne?tags=' +
    term + '&format=json&jsoncallback=?';
};
```

Существуют различные причудливые и чересчур сложные методы написания функции `url` в стиле отсутствия ссылок используя моноиды[^Мы изучим их позже] или комбинаторы. Наш выбор – читаемая версия, собирающая эту строку в обычном ссылочном стиле.

Давайте напишем функцию `app`, которая делает вызов и выводит данные на экран.

```js
var app = _.compose(Impure.getJSON(trace("response")), url);

app("cats");
```

Этот код вызывает функцию `url`, затем передает полученную строку в функцию `getJSON`, которая частично применяется с `trace`. В результате загрузки приложения, в консоли будет выведен ответ на api вызов.

<img src="images/console_ss.png"/>

Мы хотим получить изображения из этого json-объекта. Похоже, что их адреса запрятаны в элементах `items`, а конкретно – в каждом свойстве `m` объекта `media`.

Во всяком случае, для получения этих значений мы можем использовать замечательную универсальную функцию чтения из ramda, с именем `_.prop()`. Ниже представлена оригинальная версия метода:

```js
var prop = _.curry(function(property, object){
  return object[property];
});
```

Она достаточно скучная. Мы просто воспользуемся `[]`, для получения доступа к свойству какого-либо объекта. Давайте используем её и получим адреса изображений.

```js
var mediaUrl = _.compose(_.prop('m'), _.prop('media'));

var srcs = _.compose(_.map(mediaUrl), _.prop('items'));
```

Как только мы собрали элементы `items`, мы проходимся по ним функцией `map`, чтобы получить адрес каждого изображения. На выходе – замечательный массив адресов. Давайте используем этот массив в приложении, чтобы вывести изображения на экран.

```js
var renderImages = _.compose(Impure.setHtml("body"), srcs);
var app = _.compose(Impure.getJSON(renderImages), url);
```

Мы всего-навсего написали очередную композицию функций, которая вызовет `srcs` и заполнит `<body>` нашего html. Заменив `trace` на `renderImages`, мы можем отобразить что-то помимо чистого json — сейчас это просто ссылки на изображения.

Последним шагом необходимо преобразовать эти ссылки в настоящие картинки. Если бы приложение было большим, мы бы использовали шаблонизатор и библиотеку для работы с DOM, например, Handlebars или React. В нашем же приложении, нам нужен только тег img, поэтому давайте обойдемся jQuery.

```js
var img = function (url) {
  return $('<img />', { src: url });
};
```

jQuery-метод `html()` принимает массив тегов. Нам нужно только вставить адреса изображений в теги и передать их дальше в функцию `setHtml`.

```js
var images = _.compose(_.map(img), srcs);
var renderImages = _.compose(Impure.setHtml("body"), images);
var app = _.compose(Impure.getJSON(renderImages), url);
```

Вот и всё!

<img src="images/cats_ss.png" />

Ниже представлен полный скрипт:
```js
requirejs.config({
  paths: {
    ramda: 'https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min',
    jquery: 'https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min'
  }
});

require([
    'ramda',
    'jquery'
  ],
  function (_, $) {
    ////////////////////////////////////////////
    // Utils

    var Impure = {
      getJSON: _.curry(function(callback, url) {
        $.getJSON(url, callback);
      }),

      setHtml: _.curry(function(sel, html) {
        $(sel).html(html);
      })
    };

    var img = function (url) {
      return $('<img />', { src: url });
    };

    var trace = _.curry(function(tag, x) {
      console.log(tag, x);
      return x;
    });

    ////////////////////////////////////////////

    var url = function (t) {
      return 'http://api.flickr.com/services/feeds/photos_public.gne?tags=' +
        t + '&format=json&jsoncallback=?';
    };

    var mediaUrl = _.compose(_.prop('m'), _.prop('media'));

    var srcs = _.compose(_.map(mediaUrl), _.prop('items'));

    var images = _.compose(_.map(img), srcs);

    var renderImages = _.compose(Impure.setHtml("body"), images);

    var app = _.compose(Impure.getJSON(renderImages), url);

    app("cats");
  });
```

Полюбуйтесь на получившийся код. Чудесная декларативная конструкция, описывающая то, что мы хотим получить, а не как. Сейчас, мы можем рассматривать каждую строку как уравнение, свойства которого строго соблюдаются. Теперь мы можем пользоваться этими свойствами для размышлений о нашем приложении и рефакторинга.

## Принципиальный рефакторинг

Наш код можно легко улучшить. Сейчас мы проходимся функцией map по массиву чтобы получить адреса изображения, а затем уже по массиву адресов, чтобы сформировать теги . В целях оптимизации можно воспользоваться законом композиции:

```js
// Закон композиции отображений
var law = compose(map(f), map(g)) == map(compose(f, g));
```

Мы можем использовать это свойство для оптимизации кода. Давайте начнём принципиальный рефакторинг.

```js
// Текущий код
var mediaUrl = _.compose(_.prop('m'), _.prop('media'));

var srcs = _.compose(_.map(mediaUrl), _.prop('items'));

var images = _.compose(_.map(img), srcs);

```

Давайте объединим методы, использующие map. Мы можем поочерёдно выполнять `srcs` и `images`, благодаря эквивалентности и отсутствия побочных эффектов в этих функциях.

```js
var mediaUrl = _.compose(_.prop('m'), _.prop('media'));

var images = _.compose(_.map(img), _.map(mediaUrl), _.prop('items'));
```

Теперь, когда мы выстроили отображения в ряд, можно применить закон композиции.

```js
var mediaUrl = _.compose(_.prop('m'), _.prop('media'));

var images = _.compose(_.map(_.compose(img, mediaUrl)), _.prop('items'));
```

Теперь интерпретатор будет выполнять только один цикл по преобразованию элементов json в изображения, готовые к выводу на экран. Напоследок, сделаем код более читаемым, вынеся одну функцию.

```js
var mediaUrl = _.compose(_.prop('m'), _.prop('media'));

var mediaToImg = _.compose(img, mediaUrl);

var images = _.compose(_.map(mediaToImg), _.prop('items'));
```

## Итог

Использовав наши новые знания, мы построили маленькое, но практичное приложение. Основываясь на математических законах, мы отрефакторили код. Но что насчёт обработки ошибок, и ветвления кода? Как же добиться чистоты от всего приложения сразу, а не просто каждый раз выносить функции с побочными эффектами в отдельное пространство имён? Как сделать наш код более выразительным и надёжным? Ответы на эти вопросы мы рассмотрим во второй части книги.

[Глава 7: Хиндли-Милнер и Я](ch7-ru.md)
