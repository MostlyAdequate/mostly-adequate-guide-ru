# Глава 4: Каррирование

## Без тебя мне жизнь не мила

Однажды мой отец рассказал мне, что есть вещи, без которых легко обходишься, пока у тебя их нет, например: микроволновка или смартфон. Люди постарше вполне счастливо жили и без интернета. Для меня каррирование — одна из таких вещей.

Идея очень проста: вы можете вызвать функцию с меньшим количеством аргументов, чем она принимает, в ответ вы получите функцию, которая принимает оставшиеся аргументы.

Вы можете вызвать функцию как со всеми аргументами сразу, так и с любым меньшим количеством.

```js
var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);

increment(2);
// 3

addTen(2);
// 12
```

В этом примере мы определили функцию `add`, которая принимает один аргумент и возвращает функцию. Если мы её вызовем, то она запомнит первый аргумент (при помощи замыкания). Для того чтобы определять и вызывать подобные функции было проще, мы воспользуемся функцией `curry`.

Давайте же определим несколько каррированных функций.

```js
var curry = require('lodash.curry');

var match = curry(function(what, str) {
  return str.match(what);
});

var replace = curry(function(what, replacement, str) {
  return str.replace(what, replacement);
});

var filter = curry(function(f, ary) {
  return ary.filter(f);
});

var map = curry(function(f, ary) {
  return ary.map(f);
});
```

При определении этих функций я придерживался простого, но очень важного правила: я записывал последним аргументом переменную, содержащую данные, которыми мы собираемся оперировать. Позже вы поймёте, зачем я это сделал.

```js
match(/\s+/g, "hello world");
// [ ' ' ]

match(/\s+/g)("hello world");
// [ ' ' ]

var hasSpaces = match(/\s+/g);
// function(x) { return x.match(/\s+/g) }

hasSpaces("hello world");
// [ ' ' ]

hasSpaces("spaceless");
// null

filter(hasSpaces, ["tori_spelling", "tori amos"]);
// ["tori amos"]

var findSpaces = filter(hasSpaces);
// function(xs) { return xs.filter(function(x) { return x.match(/\s+/g) }) }

findSpaces(["tori_spelling", "tori amos"]);
// ["tori amos"]

var noVowels = replace(/[aeiou]/ig);
// function(replacement, x) { return x.replace(/[aeiou]/ig, replacement) }

var censored = noVowels("*");
// function(x) { return x.replace(/[aeiou]/ig, "*") }

censored("Chocolate Rain");
// 'Ch*c*l*t* R**n'
```

Здесь я продемонстрировал способность «предзагрузки» функции с аргументом или несколькими для того, чтобы получить новую функцию, которая запомнит эти аргументы.

Советую вам выполнить `npm install lodash` в консоли, скопировать код выше и поиграться с ним. То же самое можно сделать и в браузере (вам в любом случае потребуется библиотека lodash или ramda).

## Больше, чем просто приправа

Каррирование полезно во многих случаях, с его помощью мы можем создавать новые функции на лету, просто передавая меньше аргументов в уже существующие, как мы могли убедиться в случаях с `hasSpaces`, `findSpaces`, и `censored`.

Мы также можем преобразовать любую функцию, которая принимает один аргумент в функцию, принимающую массив. Для этого нам нужно просто обернуть её в `map`:

```js
var getChildren = function(x) {
  return x.childNodes;
};

var allTheChildren = map(getChildren);
```

Вызов функции с меньшим количеством аргументов, чем она принимает, называется *частичным применением*. Используя частичное применение мы можем избавиться от большого количества ненужного кода. Давайте посмотрим как могла бы выглядеть функция `allTheChildren` с некаррированной версией `map` из библиотеки lodash[^обратите внимание, аргументы передаются в другом порядке]:

```js
var allTheChildren = function(elements) {
  return _.map(elements, getChildren);
};
```

Обычно, мы не объявляем функции, которые принимают массив в качестве аргумента, потому что мы можем просто написать `map(getChildren)`. То же самое и с функциями `sort`, `filter` и другими функциями высшего порядка[^Функция высшего порядка — это функция, которая принимает в качестве аргумента или возвращает функцию.]

Когда мы говорили о *чистых функциях*, мы договорились о том, что для одного аргумента они возвращают одно значение. Это как раз то, чем занимается каррирование — каждый аргумент возвращает новую функцию, принимающую оставшиеся аргументы.

Нам совершенно безразлично, что возвращает функция: значение или другую функцию — она всё равно будет считаться чистой. Мы позволяем функции принимать больше одного аргумента за раз, но, как мы могли убедиться, это то же самое, что и убрать лишние `()` для удобства.

## Итог

Каррирование — это удобный инструмент и я очень люблю регулярно им пользоваться. С его помощью функциональное программирование становится куда менее многословным и нудным. 

Мы можем создавать новые полезные функции на лету, просто передав пару аргументов, при этом, мы сохраняем математическую строгость в определении функции, даже несмотря на то, что мы пользуемся функциями многих переменных.

Давайте познакомимся с новым инструментом — `композицией`.

[Глава 5: Пишем код с использованием композиции](ch5-ru.md)

## Упражнения

Небольшое замечание. Мы будем использовать библиотеку *ramda*, которая каррирует каждую функцию по умолчанию. В качестве альтернативы вы можете использовать *lodash-fp*, которая делает то же самое. Она написана (и поддерживается) создателем lodash. Обе библиотеки подходят для наших нужд, выбирайте какая вам больше нравится.

[ramda](http://ramdajs.com)
[lodash-fp](https://github.com/lodash/lodash-fp)

Вы можете [тестировать](https://github.com/DrBoolean/mostly-adequate-guide/tree/master/code/part1_exercises) упражнения в процессе написания или просто копипастить их в среду интерактивного выполнения и проверять — делайте как вам удобно.

Ответы на упражнения лежат в [репозитории](https://github.com/DrBoolean/mostly-adequate-guide/tree/master/code/part1_exercises/answers)

```js
var _ = require('ramda');


// Упражнение 1
//==============
// Проведите рефакторинг и избавьтесь от всех аргументов путём частичного применения функции.

var words = function(str) {
  return _.split(' ', str);
};

// Упражнение 1a
//==============
// Воспользуйтесь функцией map, чтобы создать новую функцию words, которая будет работать с массивами строк.

var sentences = undefined;


// Упражнение 2
//==============
// Проведите рефакторинг и избавьтесь от всех аргументов путём частичного применения функции.

var filterQs = function(xs) {
  return _.filter(function(x){ return match(/q/i, x);  }, xs);
};


// Упражнение 3
//==============
// Воспользуйтесь функцией _keepHighest чтобы отрефакторить функцию max.
// Функция max не должна принимать аргументов.

// Не меняйте:
var _keepHighest = function(x,y){ return x >= y ? x : y; };

// Проведите рефакторинг:
var max = function(xs) {
  return _.reduce(function(acc, x){
    return _keepHighest(acc, x);
  }, -Infinity, xs);
};


// Бонус 1:
// ============
// оберните метод slice так, чтобы он стал функциональным и каррируемым
// //[1,2,3].slice(0, 2)
var slice = undefined;


// Бонус 2:
// ============
// используйте метод slice, чтобы объявить функцию "take", которая возвращает n первых символов строки. Сделайте её каррируемой
var take = undefined;
// Пример: для значений "Something", n = 4, функция должна вернуть "Some"
```
